{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4a106b1f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/opt/anaconda3/envs/groq/bin/python\n"
     ]
    }
   ],
   "source": [
    "import sys\n",
    "print(sys.executable)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "19daef5b-7b0c-484c-a5fc-12973ce40c20",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Supervised and unsupervised learning are two fundamental types of machine learning paradigms. The key difference between them lies in the presence or absence of labeled data and the learning objective.\n",
      "\n",
      "**Supervised Learning:**\n",
      "\n",
      "In supervised learning, the machine learning model is trained on labeled data, where each example is associated with a target output or response. The goal is to learn a mapping between input data and the corresponding output labels, so the model can make predictions on new, unseen data. The model learns from the labeled data to predict the output for a given input.\n",
      "\n",
      "Characteristics of Supervised Learning:\n",
      "\n",
      "1. Labeled data: The training data is labeled with the correct output.\n",
      "2. Predictive modeling: The model learns to predict the output based on the input.\n",
      "3. Objective: Minimize the error between predicted and actual outputs.\n",
      "\n",
      "Examples of supervised learning tasks:\n",
      "\n",
      "1. Image classification: Predicting the class label of an image (e.g., dog, cat, car).\n",
      "2. Sentiment analysis: Predicting the sentiment of a text (e.g., positive, negative, neutral).\n",
      "3. Regression: Predicting a continuous output value (e.g., stock prices, energy consumption).\n",
      "\n",
      "**Unsupervised Learning:**\n",
      "\n",
      "In unsupervised learning, the machine learning model is trained on unlabeled data, and there is no target output or response. The goal is to discover patterns, relationships, or structure in the data. The model learns to identify clusters, dimensions, or anomalies in the data without any prior knowledge of the output.\n",
      "\n",
      "Characteristics of Unsupervised Learning:\n",
      "\n",
      "1. Unlabeled data: The training data is not labeled with any output.\n",
      "2. Descriptive modeling: The model learns to describe the data, identify patterns, or relationships.\n",
      "3. Objective: Identify underlying structure or patterns in the data.\n",
      "\n",
      "Examples of unsupervised learning tasks:\n",
      "\n",
      "1. Clustering: Grouping similar data points into clusters (e.g., customer segmentation).\n",
      "2. Dimensionality reduction: Reducing the number of features in the data while preserving the most important information (e.g., PCA, t-SNE).\n",
      "3. Anomaly detection: Identifying unusual or outlier data points (e.g., detecting credit card fraud).\n",
      "\n",
      "**Key differences:**\n",
      "\n",
      "1. **Labeled data**: Supervised learning requires labeled data, while unsupervised learning does not.\n",
      "2. **Learning objective**: Supervised learning aims to predict outputs, while unsupervised learning focuses on discovering patterns or structure.\n",
      "3. **Model evaluation**: Supervised learning models are typically evaluated using metrics like accuracy or mean squared error, while unsupervised learning models are often evaluated using metrics like clustering quality or dimensionality reduction quality.\n",
      "\n",
      "In summary, supervised learning is used for predictive modeling with labeled data, while unsupervised learning is used for descriptive modeling with unlabeled data. Both paradigms have their strengths and applications, and the choice between them depends on the specific problem and data characteristics.\n",
      "To perform cell-cell communication analysis using CellChat, you can follow these steps. I will provide you with a basic example of how to use CellChat with your data. Please ensure you have CellChat and necessary libraries installed in your Python environment. If not, you can install them using pip:\n",
      "\n",
      "```bash\n",
      "pip install cellchat pandas numpy\n",
      "```\n",
      "\n",
      "Here is a step-by-step example of how to perform cell-cell communication analysis with CellChat. Please save this code in a Python file (e.g., `cellchat_analysis.py`) and run it in your environment.\n",
      "\n",
      "```python\n",
      "import pandas as pd\n",
      "import cellchat\n",
      "\n",
      "# Load input data\n",
      "data = pd.read_csv('data_input.csv', index_col=0)\n",
      "meta = pd.read_csv('meta.csv', index_col=0)\n",
      "\n",
      "# Initialize CellChat object\n",
      "cellchat_obj = cellchat.CellChat(data, meta)\n",
      "\n",
      "# Identify potential ligand-receptor pairs based on databases\n",
      "cellchat_obj.identify_overexpressed_genes()\n",
      "cellchat_obj.identify_potential_ligand_receptors()\n",
      "\n",
      "# Infer cell-cell communication based on the identified ligand-receptor pairs\n",
      "cellchat_obj.compute_communication()\n",
      "\n",
      "# Save the inferred cell-cell communication to a file\n",
      "cellchat_obj.save_communication('cellchat_results.h5ad')\n",
      "\n",
      "print(\"Cell-cell communication analysis completed.\")\n",
      "```\n",
      "\n",
      "In this code:\n",
      "1. We load the input data (`data_input.csv`) and metadata (`meta.csv`) into DataFrames.\n",
      "2. We initialize a `CellChat` object with the data and metadata.\n",
      "3. We identify overexpressed genes in each cell type and potential ligand-receptor pairs based on the databases integrated with CellChat.\n",
      "4. We compute the inferred cell-cell communication based on the identified ligand-receptor pairs.\n",
      "5. We save the results to an `.h5ad` file named `cellchat_results.h5ad`.\n",
      "\n",
      "Note: This is a basic example. Depending on your dataset and requirements, you might need to perform additional steps such as dataset preprocessing, tuning parameters, or visualizing the results. Please refer to the CellChat documentation and tutorials for more detailed instructions and customization options.\n"
     ]
    }
   ],
   "source": [
    "#test groq\n",
    "#！export GROQ_API_KEY=\"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\"\n",
    "#！echo $GROQ_API_KEY\n",
    "\n",
    "\n",
    "import os\n",
    "from groq import Groq\n",
    "\n",
    "# Initialize the client with the API key from environment variables\n",
    "api_key = \"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\"\n",
    "client = Groq(api_key=api_key)\n",
    "\n",
    "try:\n",
    "    # Create a chat completion request\n",
    "    chat_completion = client.chat.completions.create(\n",
    "        messages=[\n",
    "            {\n",
    "                \"role\": \"user\",\n",
    "                \"content\": \"Explain the differences between supervised and unsupervised learning.\"\n",
    "            }\n",
    "        ],\n",
    "        model=\"llama-3.3-70b-versatile\",\n",
    "    )\n",
    "    # Extract and print the response content\n",
    "    response = chat_completion.choices[0].message.content\n",
    "    print(response)\n",
    "    # Save the response to a text file\n",
    "    with open(\"response_output.txt\", \"w\") as file:\n",
    "        file.write(response)\n",
    "except Exception as e:\n",
    "    print(f\"An error occurred: {e}\")\n",
    "\n",
    "\n",
    "# Initialize the client with the API key from environment variables\n",
    "api_key = \"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\"\n",
    "client = Groq(api_key=api_key)\n",
    "\n",
    "try:\n",
    "    # Create a chat completion request\n",
    "    chat_completion = client.chat.completions.create(\n",
    "        messages=[\n",
    "            {\n",
    "                \"role\": \"user\",\n",
    "                \"content\": \"Help me do cell-cell communication analysis by CellChat using data_input.csv and meta.csv in the current folder.\"\n",
    "            }\n",
    "        ],\n",
    "        model=\"llama-3.3-70b-versatile\",\n",
    "    )\n",
    "    # Extract and print the response content\n",
    "    response = chat_completion.choices[0].message.content\n",
    "    print(response)\n",
    "    # Save the response to a text file\n",
    "    with open(\"response_output.txt\", \"w\") as file:\n",
    "        file.write(response)\n",
    "except Exception as e:\n",
    "    print(f\"An error occurred: {e}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e1d8ca6e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# cellchat agent api setup\n",
    "#！export GROQ_API_KEY=\"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\"\n",
    "#！echo $GROQ_API_KEY\n",
    "# Importing required libraries\n",
    "from groq import Groq\n",
    "import os\n",
    "import json\n",
    "from rpy2.robjects import r as ro\n",
    "\n",
    "# Optionally, load the API key from an environment variable or a file\n",
    "# If you are storing the API key in an environment variable:\n",
    "api_key = \"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\"\n",
    "client = Groq(api_key=api_key)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "MODEL = \"llama3-70b-8192\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9ec6f592",
   "metadata": {},
   "outputs": [],
   "source": [
    "# CellChat agent Functions define"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c8e8dfd7-f157-45ff-aded-192ec06b5261",
   "metadata": {},
   "source": [
    "###format checker\n",
    "import rpy2.robjects as ro\n",
    "\n",
    "def format_checker(input_file, meta_file):\n",
    "    \"\"\"Checks whether the format of data_input.csv and meta.csv meets the requirements for CellChat analysis.\"\"\"\n",
    "    ro.r(f\"\"\"\n",
    "        # Load required libraries\n",
    "        library(Matrix)\n",
    "        library(CellChat)\n",
    "        # Read input files\n",
    "        data.input <- tryCatch({{\n",
    "            read.csv(\"{input_file}\", row.names = 1)\n",
    "        }}, error = function(e) {{\n",
    "            stop(paste(\"Error in reading data_input.csv:\", e$message))\n",
    "        }})\n",
    "        meta <- tryCatch({{\n",
    "            read.csv(\"{meta_file}\", row.names = 1)\n",
    "        }}, error = function(e) {{\n",
    "            stop(paste(\"Error in reading meta.csv:\", e$message))\n",
    "        }})\n",
    "        # Check if the number of row names in meta matches the number of column names in data.input\n",
    "        if (!all(rownames(meta) %in% colnames(data.input)) || !all(colnames(data.input) %in% rownames(meta))) {{\n",
    "            stop(\"Error: Row names of meta.csv do not match column names of data_input.csv.\")\n",
    "        }}\n",
    "        # Check if 'labels' column exists in meta\n",
    "        if (!\"labels\" %in% colnames(meta)) {{\n",
    "            stop(\"Error: 'labels' column is missing in meta.csv.\")\n",
    "        }}\n",
    "        # Convert data.input to sparse matrix (dgCMatrix) and check if successful\n",
    "        data.input <- as(as.matrix(data.input), \"dgCMatrix\")\n",
    "        # If all checks pass\n",
    "        print(\"Format check passed: Files are correctly formatted for CellChat analysis.\")\n",
    "    }}, error = function(e) {{\n",
    "        print(e$message)\n",
    "    \"\"\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "8609b291-1a00-4f7e-9743-60f86037215b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def host_workflow(input_file, meta_file):\n",
    "    \"\"\"\n",
    "    Host function that explains the CellChat workflow and allows users to choose steps before execution.\n",
    "    \"\"\"\n",
    "    print(\"\\n📢 **Welcome to the CellChat Analysis Pipeline!**\")\n",
    "    print(\"This workflow consists of multiple steps, each performing a critical function.\")\n",
    "    \n",
    "    # Step 2: Database Selection - Ask once at the beginning\n",
    "    species_input = input(\"\\nSelect species: Human (h) or Mouse (m): \").strip().lower()\n",
    "    species = \"human\" if species_input == \"h\" else \"mouse\"\n",
    "    \n",
    "    print(\"\\nAvailable Database Subsets:\")\n",
    "    print(\"  1: Secreted Signaling\")\n",
    "    print(\"  2: ECM-Receptor\")\n",
    "    print(\"  3: Cell-Cell Contact\")\n",
    "    print(\"  4: Non-protein Signaling\")\n",
    "    \n",
    "    subset_input = input(\"\\nEnter the numbers of the subsets to use (comma-separated, e.g., 1,3): \").strip()\n",
    "    subset_map = {\"1\": \"Secreted Signaling\", \"2\": \"ECM-Receptor\", \"3\": \"Cell-Cell Contact\", \"4\": \"Non-protein Signaling\"}\n",
    "    subsets = [subset_map[s] for s in subset_input.split(',') if s in subset_map]\n",
    "    \n",
    "    steps_to_run = {\n",
    "        \"format_checker\": True,  # Always needed\n",
    "        \"database_identifier\": True,\n",
    "        \"cellchat_analysis\": input(\"\\nDo you want to run CellChat Analysis? (y/n): \").strip().lower() == \"y\",\n",
    "        \"visual_signal_pathway\": input(\"\\nDo you want to run Visualization of Signaling Pathways? (y/n): \").strip().lower() == \"y\",\n",
    "        \"visual_LR\": input(\"\\nDo you want to run Visualization of Ligand-Receptor? (y/n): \").strip().lower() == \"y\",\n",
    "        \"visual_gene\": input(\"\\nDo you want to plot the Signaling Gene Expression Distribution? (y/n): \").strip().lower() == \"y\",\n",
    "        \"identify_signaling_roles\": input(\"\\nDo you want to analyze Signaling Roles of Cell Groups? (y/n): \").strip().lower() == \"y\",\n",
    "        \"identify_global_communication_patterns\": input(\"\\nDo you want to identify global communication patterns? (y/n): \").strip().lower() == \"y\",\n",
    "        \"analyze_signaling_similarity\": input(\"\\nDo you want to analyze signaling similarity? (y/n): \").strip().lower() == \"y\",\n",
    "        \"save_cellchat\": input(\"\\nDo you want to save the CellChat Object? (y/n): \").strip().lower() == \"y\",\n",
    "    }\n",
    "    \n",
    "    print(\"\\n✅ **Starting Analysis with Selected Steps...**\\n\")\n",
    "    \n",
    "    # Step 1: Format Checking\n",
    "    print(\"🔎 **Running Format Checker...**\")\n",
    "    format_checker(input_file, meta_file)\n",
    "    print(\"✅ Format check completed.\\n\")\n",
    "    \n",
    "    # Step 2: Database Selection (Using inputs collected above)\n",
    "    print(\"📚 **Running Database Selection...**\")\n",
    "    database_identifier(species=species, subsets=subsets)\n",
    "    print(f\"✅ Database setup completed: Species = {species}, Subsets = {', '.join(subsets)}\\n\")\n",
    "    \n",
    "    # Step 3: CellChat Analysis\n",
    "    if steps_to_run[\"cellchat_analysis\"]:\n",
    "        print(\"🔬 **Running CellChat Analysis...**\")\n",
    "        cellchat_analysis(input_file, meta_file)\n",
    "        print(\"✅ CellChat analysis completed.\\n\")\n",
    "    \n",
    "    # Step 4: Visualization of Signaling Pathways\n",
    "    if steps_to_run[\"visual_signal_pathway\"]:\n",
    "        print(\"📈 **Running Visualization of Signaling Pathways...**\")\n",
    "        visual_signal_pathway()\n",
    "        print(\"✅ Visualization completed.\\n\")\n",
    "    \n",
    "    # Step 5: Visualization of Ligand-Receptor and Pathways\n",
    "    if steps_to_run[\"visual_LR\"]:\n",
    "        print(\"📈 **Running Visualization of Ligand-Receptor...**\")\n",
    "        visual_LR()\n",
    "        print(\"✅ Visualization completed.\\n\")\n",
    "    \n",
    "    # Step 6: Visualization of Gene Expression\n",
    "    if steps_to_run[\"visual_gene\"]:\n",
    "        print(\"📈 **Running Visualization of Gene Expression...**\")\n",
    "        visual_gene()\n",
    "        print(\"✅ Visualization completed.\\n\")\n",
    "    \n",
    "    # Step 7: Visualization of Signaling Roles\n",
    "    if steps_to_run[\"identify_signaling_roles\"]:\n",
    "        print(\"📈 **Running Analysis of Signaling Roles...**\")\n",
    "        identify_signaling_roles()\n",
    "        print(\"✅ Analysis completed.\\n\")\n",
    "\n",
    "    # Step 8: Visualization of Signaling Roles\n",
    "    if steps_to_run[\"identify_global_communication_patterns\"]:\n",
    "        print(\"📈 **Running Analysis of Global Communication Patterns...**\")\n",
    "        identify_global_communication_patterns()\n",
    "        print(\"✅ Analysis completed.\\n\")\n",
    "\n",
    "    # Step 9: Visualization of Signaling Roles\n",
    "    if steps_to_run[\"analyze_signaling_similarity\"]:\n",
    "        print(\"📈 **Running Analysis of Signaling Similarity...**\")\n",
    "        analyze_signaling_similarity()\n",
    "        print(\"✅ Analysis completed.\\n\")\n",
    "    \n",
    "    # Step 10: Save CellChat Object\n",
    "    if steps_to_run[\"save_cellchat\"]:\n",
    "        print(\"💾 **Saving CellChat Object...**\")\n",
    "        save_path = input(\"Enter path to save CellChat RDS file (e.g., 'cellchat_object.rds'): \").strip()\n",
    "        save_cellchat(output_file=save_path)\n",
    "        print(f\"✅ CellChat analysis and results saved at {save_path}\\n\")\n",
    "    \n",
    "    print(\"\\n🎉 **Workflow Completed!** All selected CellChat analysis steps executed successfully.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3a5e7243-2ba8-4255-a378-e6fe614f9736",
   "metadata": {},
   "outputs": [],
   "source": [
    "import rpy2.robjects as ro\n",
    "\n",
    "def format_checker(input_file, meta_file):\n",
    "    \"\"\"\n",
    "    Checks whether the format of data_input.csv and meta.csv meets the requirements for CellChat analysis.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        ro.r(f\"\"\"\n",
    "            library(Matrix)\n",
    "            library(CellChat)\n",
    "            # Read input files\n",
    "            data.input <- tryCatch({{\n",
    "                read.csv(\"{input_file}\", row.names = 1)\n",
    "            }}, error = function(e) {{\n",
    "                stop(paste(\"Error in reading data_input.csv:\", e$message))\n",
    "            }})\n",
    "            meta <- tryCatch({{\n",
    "                read.csv(\"{meta_file}\", row.names = 1)\n",
    "            }}, error = function(e) {{\n",
    "                stop(paste(\"Error in reading meta.csv:\", e$message))\n",
    "            }})\n",
    "            # Check if row names in meta match column names in data.input\n",
    "            if (!all(rownames(meta) %in% colnames(data.input)) || !all(colnames(data.input) %in% rownames(meta))) {{\n",
    "                stop(\"Error: Row names of meta.csv do not match column names of data_input.csv.\")\n",
    "            }}\n",
    "            # Check if 'labels' column exists in meta\n",
    "            if (!\"labels\" %in% colnames(meta)) {{\n",
    "                stop(\"Error: 'labels' column is missing in meta.csv.\")\n",
    "            }}\n",
    "            # Convert data.input to sparse matrix\n",
    "            data.input <- as(as.matrix(data.input), \"dgCMatrix\")\n",
    "            # Success message\n",
    "            print(\"Format check passed: Files are correctly formatted for CellChat analysis.\")\n",
    "        \"\"\")\n",
    "    except Exception as e:\n",
    "        print(f\"R Parsing Error: {e}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "2724b49d",
   "metadata": {},
   "outputs": [],
   "source": [
    "##databased identifier\n",
    "def database_identifier(species: str = None, subsets: list = None, exclude: str = None):\n",
    "    \"\"\"Identify the species and subset of CellChatDB for use.\"\"\"\n",
    "    print(f\"Selected species: {species.capitalize()}\")\n",
    "    print(f\"Selected subsets: {', '.join(subsets)}\")\n",
    "    \n",
    "    # Define the R script dynamically based on user input\n",
    "    ro.r(f'''\n",
    "        library(CellChat)\n",
    "        # Choose species\n",
    "        if (\"{species}\" == \"mouse\") {{\n",
    "            CellChatDB <- CellChatDB.mouse\n",
    "        }} else {{\n",
    "            CellChatDB <- CellChatDB.human\n",
    "        }}\n",
    "        # Choose subset of CellChatDB\n",
    "        selected_categories <- c({', '.join([f'\"{s}\"' for s in subsets])})\n",
    "        CellChatDB.use <- subsetDB(CellChatDB, search = selected_categories, key = \"annotation\")\n",
    "        print(\"Database_identifier completed.\")\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "670f3a59",
   "metadata": {},
   "outputs": [],
   "source": [
    "##whole process of cellchat analysis\n",
    "def cellchat_analysis(input_file, meta_file):\n",
    "    ro.r(f\"\"\"\n",
    "        # Load required libraries\n",
    "        library(CellChat)\n",
    "        library(Matrix)\n",
    "        library(ggplot2)\n",
    "        library(future)\n",
    "        # Read input data\n",
    "        data.input <- read.csv(\"{input_file}\", row.names = 1)\n",
    "        meta <- read.csv(\"{meta_file}\", row.names = 1)\n",
    "        # Convert data formats\n",
    "        data.input <- as(as.matrix(data.input), \"dgCMatrix\")\n",
    "        meta <- as.data.frame(meta)\n",
    "        print(\"Data and metadata prepared.\")\n",
    "        # Create CellChat object\n",
    "        cellchat <- createCellChat(object = data.input, meta = meta, group.by = \"labels\")\n",
    "        print(\"CellChat object created.\")\n",
    "        # Load CellChat database\n",
    "        CellChatDB <- CellChatDB.human  # Change to CellChatDB.mouse if needed\n",
    "        cellchat@DB <- CellChatDB\n",
    "        # Preprocessing steps\n",
    "        cellchat <- subsetData(cellchat)\n",
    "        future::plan(\"multisession\", workers = 4)  # Enable parallel processing\n",
    "        cellchat <- identifyOverExpressedGenes(cellchat)\n",
    "        cellchat <- identifyOverExpressedInteractions(cellchat)\n",
    "        print(\"Preprocessing completed.\")\n",
    "        # Compute communication probabilities\n",
    "        ptm <- Sys.time()\n",
    "        cellchat <- computeCommunProb(cellchat, type = \"triMean\")\n",
    "        # Optional: Filter communication based on minimum number of cells\n",
    "        cellchat <- filterCommunication(cellchat, min.cells = 10)\n",
    "        # Compute pathway-level communication probabilities\n",
    "        cellchat <- computeCommunProbPathway(cellchat)\n",
    "        # Extract communication data\n",
    "        df.net <- subsetCommunication(cellchat)\n",
    "        write.csv(df.net, \"net.csv\")\n",
    "        df.netP <- subsetCommunication(cellchat, slot.name = \"netP\")\n",
    "        write.csv(df.netP, \"netP.csv\")\n",
    "        print(\"Cell-cell communication inference completed.\")\n",
    "        # Aggregate cell-cell communication network\n",
    "        cellchat <- aggregateNet(cellchat)\n",
    "        execution.time <- Sys.time() - ptm\n",
    "        print(as.numeric(execution.time, units = \"secs\"))\n",
    "        # Get group sizes\n",
    "        groupSize <- as.numeric(table(cellchat@idents))\n",
    "        # Generate and save network visualization plots\n",
    "        pdf(\"Number_of_interactions.pdf\")\n",
    "        netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = TRUE, label.edge = FALSE,\n",
    "                         title.name = \"Number of interactions\")\n",
    "        dev.off()\n",
    "        pdf(\"Interaction_weights_strength.pdf\")\n",
    "        netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = TRUE, label.edge = FALSE,\n",
    "                         title.name = \"Interaction weights/strength\")\n",
    "        dev.off()\n",
    "        # Generate interaction-specific network plots\n",
    "        mat <- cellchat@net$weight\n",
    "        for (i in 1:nrow(mat)) {{\n",
    "            pdf(paste0(\"Interaction_\", rownames(mat)[i], \".pdf\"))\n",
    "            mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))\n",
    "            mat2[i, ] <- mat[i, ]\n",
    "            netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = TRUE, edge.weight.max = max(mat),\n",
    "                             title.name = rownames(mat)[i])\n",
    "            dev.off()\n",
    "        }}\n",
    "        saveRDS(cellchat, \"cellchat_object.rds\")\n",
    "        cellchat@idents <- factor(cellchat@idents)\n",
    "        print(\"CellChat analysis completed.\")\n",
    "    \"\"\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "37995d45-c80a-4eb5-a73b-5a95956de7d6",
   "metadata": {},
   "outputs": [],
   "source": [
    "def visual_signal_pathway():\n",
    "    \"\"\"\n",
    "    Function to visualize CellChat results based on user input.\n",
    "    \"\"\"\n",
    "    ro.r('''\n",
    "        # Function to get valid numeric input with repeated prompting\n",
    "        get_numeric_input <- function(prompt_msg, valid_range = NULL, allow_multiple = FALSE) {\n",
    "            repeat {\n",
    "                input <- readline(prompt=prompt_msg)\n",
    "                if (input == \"\") {\n",
    "                    cat(\"Input cannot be empty. Please enter a valid response.\\n\")\n",
    "                } else {\n",
    "                    num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric vector\n",
    "                    if (any(is.na(num_values))) {\n",
    "                        cat(\"Invalid input. Please enter a valid number.\\n\")\n",
    "                    } else if (!is.null(valid_range) && (any(num_values < valid_range[1]) || any(num_values > valid_range[2]))) {\n",
    "                        cat(\"Invalid choice. Please enter a number between\", valid_range[1], \"and\", valid_range[2], \".\\n\")\n",
    "                    } else {\n",
    "                        return(num_values)  # Return valid numeric input\n",
    "                    }\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Prompt user for plot type selection (allows multiple selections)\n",
    "        cat(\"Visualization options:\\n\")\n",
    "        cat(\"1) Hierarchy plot - Shows autocrine and paracrine signaling between cell groups.\\n\")\n",
    "        cat(\"2) Circle plot - Displays network communication among all cell types.\\n\")\n",
    "        cat(\"3) Chord diagram - Represents signaling relationships in a flexible format.\\n\")\n",
    "        cat(\"4) Heatmap - Shows pathway interactions in heatmap format.\\n\")\n",
    "\n",
    "        plot_type <- get_numeric_input(\"Enter the number of the plot type(s) you want to visualize (comma-separated): \", c(1, 4), TRUE)\n",
    "\n",
    "        # Extract unique cell types\n",
    "        cell_types <- levels(cellchat@idents)\n",
    "\n",
    "        # Print available cell types\n",
    "        cat(\"Available cell types:\\n\")\n",
    "        for (i in seq_along(cell_types)) {\n",
    "            cat(i, \")\", cell_types[i], \"\\n\")\n",
    "        }\n",
    "\n",
    "        # Ask user to select receiver cell types\n",
    "        vertex_receiver <- get_numeric_input(\"Enter indices of receiver cell types (comma-separated): \", c(1, length(cell_types)), TRUE)\n",
    "\n",
    "        cat(\"Selected receiver cell types:\\n\")\n",
    "        print(cell_types[vertex_receiver])\n",
    "\n",
    "        # Extract available pathways\n",
    "        pathways <- cellchat@netP$pathways\n",
    "\n",
    "        # Print available pathways\n",
    "        cat(\"Available pathways:\\n\")\n",
    "        for (i in seq_along(pathways)) {\n",
    "            cat(i, \")\", pathways[i], \"\\n\")\n",
    "        }\n",
    "\n",
    "        # Ask user to select pathways\n",
    "        repeat {\n",
    "            pathway_input <- readline(\"Enter indices of signaling pathways to visualize (comma-separated or 'all'): \")\n",
    "            if (pathway_input == \"\") {\n",
    "                cat(\"Input cannot be empty. Please enter valid indices or 'all'.\\n\")\n",
    "            } else if (tolower(pathway_input) == \"all\") {\n",
    "                pathways_show <- pathways\n",
    "                break\n",
    "            } else {\n",
    "                pathway_indices <- as.numeric(unlist(strsplit(pathway_input, \",\")))\n",
    "                if (any(is.na(pathway_indices)) || any(pathway_indices < 1) || any(pathway_indices > length(pathways))) {\n",
    "                    cat(\"Invalid input. Please enter valid indices between 1 and\", length(pathways), \"or type 'all'.\\n\")\n",
    "                } else {\n",
    "                    pathways_show <- pathways[pathway_indices]\n",
    "                    break\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Loop over selected plot types and pathways\n",
    "        for (type in plot_type) {\n",
    "            for (pathway in pathways_show) {\n",
    "                output_file <- paste0(pathway, \"_\", c(\"hierarchy\", \"circle\", \"chord\", \"heatmap\")[type], \".pdf\")\n",
    "                pdf(output_file)\n",
    "                \n",
    "                if (type == 1) {\n",
    "                    netVisual_aggregate(cellchat, signaling = pathway, vertex.receiver = vertex_receiver)\n",
    "                } else if (type == 2) {\n",
    "                    netVisual_aggregate(cellchat, signaling = pathway, layout = \"circle\")\n",
    "                } else if (type == 3) {\n",
    "                    netVisual_aggregate(cellchat, signaling = pathway, layout = \"chord\")\n",
    "                } else if (type == 4) {\n",
    "                    netVisual_heatmap(cellchat, signaling = pathway, color.heatmap = \"Reds\")\n",
    "                }\n",
    "                \n",
    "                dev.off()\n",
    "                cat(\"Saved:\", output_file, \"\\n\")\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Ask user if they want to compute ligand-receptor contributions\n",
    "        repeat {\n",
    "            compute_contribution <- readline(\"Do you want to compute and visualize ligand-receptor pair contributions? (y/n): \")\n",
    "            if (compute_contribution == \"\") {\n",
    "                cat(\"Input cannot be empty. Please enter 'y' or 'n'.\\n\")\n",
    "            } else if (tolower(compute_contribution) == \"y\") {\n",
    "                for (pathway in pathways_show) {\n",
    "                    gg <- netAnalysis_contribution(cellchat, signaling = pathway)\n",
    "                    ggsave(filename=paste0(pathway, \"_L-R_contribution.pdf\"), plot=gg, width = 3, height = 2, units = 'in', dpi = 300)\n",
    "                    \n",
    "                    # Extract and show enriched ligand-receptor pairs\n",
    "                    pairLR <- extractEnrichedLR(cellchat, signaling = pathway, geneLR.return = FALSE)\n",
    "                    cat(\"Enriched Ligand-Receptor Pairs for\", pathway, \":\\n\")\n",
    "                    for (i in seq_len(nrow(pairLR))) {\n",
    "                        cat(i, \") Interaction:\", pairLR$interaction_name[i], \"\\n\")\n",
    "                    }\n",
    "                    \n",
    "                    # Prompt user to select specific pair for visualization\n",
    "                    repeat {\n",
    "                        LR_choice <- get_numeric_input(\"Choose a number to visualize a specific L-R pair: \", c(1, nrow(pairLR)), FALSE)\n",
    "                        if (length(LR_choice) == 1 && LR_choice >= 1 && LR_choice <= nrow(pairLR)) {\n",
    "                            LR.show <- pairLR[LR_choice, , drop=FALSE]  # Select specific pair\n",
    "                            \n",
    "                            pdf(paste0(pathway, \"_LR_hierarchy_\", LR.show$interaction_name, \".pdf\"))\n",
    "                            netVisual_individual(cellchat, signaling = pathway, pairLR.use = LR.show, vertex.receiver = vertex_receiver)\n",
    "                            dev.off()\n",
    "                            \n",
    "                            pdf(paste0(pathway, \"_LR_circle_\", LR.show$interaction_name, \".pdf\"))\n",
    "                            netVisual_individual(cellchat, signaling = pathway, pairLR.use = LR.show, layout = \"circle\")\n",
    "                            dev.off()\n",
    "                            \n",
    "                            cat(\"Visualization saved for L-R pair:\", LR.show$interaction_name, \"\\n\")\n",
    "                            break\n",
    "                        } else {\n",
    "                            cat(\"Invalid choice. Please enter a number between 1 and\", nrow(pairLR), \".\\n\")\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "                break\n",
    "            } else if (tolower(compute_contribution) == \"n\") {\n",
    "                break\n",
    "            } else {\n",
    "                cat(\"Invalid input. Please enter 'y' or 'n'.\\n\")\n",
    "            }\n",
    "        }\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "d7f06c8d-bcba-40ae-b456-855e3c30c926",
   "metadata": {},
   "outputs": [],
   "source": [
    "def visual_LR():\n",
    "    \"\"\"\n",
    "    Function to identify sender and receiver cell groups and visualize cell-cell communication.\n",
    "    \"\"\"\n",
    "    ro.r('''\n",
    "        # Function to get valid numeric input with repeated prompting\n",
    "        get_numeric_input <- function(prompt_msg, valid_range = NULL, allow_multiple = FALSE) {\n",
    "            repeat {\n",
    "                input <- readline(prompt=prompt_msg)\n",
    "                if (input == \"\") {\n",
    "                    cat(\"Input cannot be empty. Please enter a valid response.\\n\")\n",
    "                } else {\n",
    "                    num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric vector\n",
    "                    if (any(is.na(num_values))) {\n",
    "                        cat(\"Invalid input. Please enter a valid number.\\n\")\n",
    "                    } else if (!is.null(valid_range) && (any(num_values < valid_range[1]) || any(num_values > valid_range[2]))) {\n",
    "                        cat(\"Invalid choice. Please enter a number between\", valid_range[1], \"and\", valid_range[2], \".\\n\")\n",
    "                    } else {\n",
    "                        return(num_values)  # Return valid numeric input\n",
    "                    }\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Display available cell types with numbering\n",
    "        cat(\"Available cell types:\\n\")\n",
    "        cell_types <- levels(cellchat@idents)\n",
    "        for (i in seq_along(cell_types)) {\n",
    "            cat(i, \")\", cell_types[i], \"\\n\")\n",
    "        }\n",
    "\n",
    "        # Ask user to select sender cell types\n",
    "        sources_use <- get_numeric_input(\n",
    "            \"Enter indices of sender cell types (comma-separated): \", \n",
    "            c(1, length(cell_types)), \n",
    "            TRUE\n",
    "        )\n",
    "\n",
    "        # Ask user to select receiver cell types\n",
    "        vertex_receiver <- get_numeric_input(\n",
    "            \"Enter indices of receiver cell types (comma-separated): \", \n",
    "            c(1, length(cell_types)), \n",
    "            TRUE\n",
    "        )\n",
    "\n",
    "        cat(\"Selected sender cell types:\\n\")\n",
    "        print(cell_types[sources_use])\n",
    "        cat(\"Selected receiver cell types:\\n\")\n",
    "        print(cell_types[vertex_receiver])\n",
    "\n",
    "        # Extract available pathways\n",
    "        pathways <- cellchat@netP$pathways\n",
    "\n",
    "        # Display available pathways with numbering\n",
    "        cat(\"Available pathways:\\n\")\n",
    "        for (i in seq_along(pathways)) {\n",
    "            cat(i, \")\", pathways[i], \"\\n\")\n",
    "        }\n",
    "\n",
    "        # Ask user to select pathways\n",
    "        repeat {\n",
    "            signaling_input <- readline(\"Enter indices of signaling pathways to visualize (comma-separated or 'all'): \")\n",
    "            if (signaling_input == \"\") {\n",
    "                cat(\"Input cannot be empty. Please enter valid indices or 'all'.\\n\")\n",
    "            } else if (tolower(signaling_input) == \"all\") {\n",
    "                signaling <- pathways\n",
    "                break\n",
    "            } else {\n",
    "                signaling_indices <- as.numeric(unlist(strsplit(signaling_input, \",\")))\n",
    "                if (any(is.na(signaling_indices)) || any(signaling_indices < 1) || any(signaling_indices > length(pathways))) {\n",
    "                    cat(\"Invalid input. Please enter valid indices between 1 and\", length(pathways), \"or type 'all'.\\n\")\n",
    "                } else {\n",
    "                    signaling <- pathways[signaling_indices]\n",
    "                    break\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Sorting options\n",
    "        sort_choice <- readline(\"Do you want to set the order of interacting cell pairs on x-axis? (y/n): \")\n",
    "        sort_by_target <- FALSE\n",
    "        sort_by_source <- FALSE\n",
    "        source_priority <- TRUE\n",
    "        \n",
    "        if (tolower(sort_choice) == \"y\") {\n",
    "            sort_by_target <- readline(\"Sort by target cell types? (y/n): \") == \"y\"\n",
    "            sort_by_source <- readline(\"Sort by source cell types? (y/n): \") == \"y\"\n",
    "            if (sort_by_target && sort_by_source) {\n",
    "                source_priority <- readline(\"Prioritize source order? (y/n): \") == \"y\"\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Ask user which type of plot they want\n",
    "        cat(\"Visualization options:\\n\")\n",
    "        cat(\"1) Bubble plot - Shows significant L-R pairs and interactions.\\n\")\n",
    "        cat(\"2) Chord diagram - Displays interactions between defined sender and receiver groups.\\n\")\n",
    "\n",
    "        plot_type <- get_numeric_input(\n",
    "            \"Enter the number of the plot type(s) you want to visualize (comma-separated): \", \n",
    "            c(1, 2), \n",
    "            TRUE\n",
    "        )\n",
    "\n",
    "        # Visualization\n",
    "        if (1 %in% plot_type) {\n",
    "            pdf(\"bubble_plot_false.pdf\")\n",
    "            netVisual_bubble(cellchat, sources.use = sources_use, targets.use = vertex_receiver, signaling = signaling, remove.isolate = FALSE, sort.by.target = sort_by_target, sort.by.source = sort_by_source, sort.by.source.priority = source_priority)\n",
    "            dev.off()\n",
    "\n",
    "            pdf(\"bubble_plot_true.pdf\")\n",
    "            pairLR.use <- extractEnrichedLR(cellchat, signaling = signaling)\n",
    "            netVisual_bubble(cellchat, sources.use = sources_use, targets.use = vertex_receiver, pairLR.use = pairLR.use, remove.isolate = TRUE, sort.by.target = sort_by_target, sort.by.source = sort_by_source, sort.by.source.priority = source_priority)\n",
    "            dev.off()\n",
    "            cat(\"Bubble plot saved as 'bubble_plot_false.pdf' and 'bubble_plot_true.pdf'\\n\")\n",
    "        }\n",
    "\n",
    "        if (2 %in% plot_type) {\n",
    "            show_all <- readline(\"Do you want to show all significant signaling pathways from sources to targets? (y/n): \")\n",
    "            if (tolower(show_all) == \"y\") {\n",
    "                pdf(\"chord_diagram_all.pdf\")\n",
    "                netVisual_chord_gene(cellchat, sources.use = sources_use, targets.use = vertex_receiver, slot.name = \"netP\", legend.pos.x = 10)\n",
    "                dev.off()\n",
    "                cat(\"Chord diagram saved as 'chord_diagram_all.pdf'\\n\")\n",
    "            } else {\n",
    "                pdf(\"chord_diagram.pdf\")\n",
    "                netVisual_chord_gene(cellchat, sources.use = sources_use, targets.use = vertex_receiver, signaling = signaling)\n",
    "                dev.off()\n",
    "                cat(\"Chord diagram saved as 'chord_diagram.pdf'\\n\")\n",
    "            }\n",
    "        }\n",
    "\n",
    "        if (!any(plot_type %in% c(1, 2))) {\n",
    "            cat(\"Invalid selection. Please choose a valid plot type.\\n\")\n",
    "        }\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "475a1cf3-f9ac-4036-bc17-859db636f2b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def visual_gene():\n",
    "    \"\"\"\n",
    "    Function to prompt the user and plot the signaling gene expression distribution using violin or dot plot.\n",
    "    \"\"\"\n",
    "    ro.r('''\n",
    "        # Display available pathways with numbering\n",
    "        pathways <- cellchat@netP$pathways\n",
    "        cat(\"Available pathways:\\n\")\n",
    "        for (i in seq_along(pathways)) {\n",
    "            cat(i, \")\", pathways[i], \"\\n\")\n",
    "        }\n",
    "        cat(\"Total number of pathways:\", length(pathways), \"\\n\")\n",
    "\n",
    "        # Function to get valid numeric input with repeated prompting\n",
    "        get_numeric_input <- function(prompt_msg, valid_range = NULL, allow_multiple = FALSE) {\n",
    "            repeat {\n",
    "                input <- readline(prompt=prompt_msg)\n",
    "                if (input == \"\") {\n",
    "                    cat(\"Input cannot be empty. Please enter a valid response.\\n\")\n",
    "                } else {\n",
    "                    num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric vector\n",
    "                    if (any(is.na(num_values))) {\n",
    "                        cat(\"Invalid input. Please enter a valid number.\\n\")\n",
    "                    } else if (!is.null(valid_range) && (any(num_values < valid_range[1]) || any(num_values > valid_range[2]))) {\n",
    "                        cat(\"Invalid choice. Please enter a number between\", valid_range[1], \"and\", valid_range[2], \".\\n\")\n",
    "                    } else {\n",
    "                        return(num_values)  # Return valid numeric input\n",
    "                    }\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Prompt user for signaling pathways\n",
    "        repeat {\n",
    "            signaling_input <- readline(\"Enter indices of signaling pathway(s) to visualize (comma-separated or 'all'): \")\n",
    "            if (tolower(signaling_input) == \"all\") {\n",
    "                signaling <- pathways\n",
    "                break\n",
    "            } else {\n",
    "                pathway_indices <- as.numeric(unlist(strsplit(signaling_input, \",\")))\n",
    "                if (any(is.na(pathway_indices)) || any(pathway_indices < 1) || any(pathway_indices > length(pathways))) {\n",
    "                    cat(\"Invalid input. Please enter valid indices between 1 and\", length(pathways), \"or type 'all'.\\n\")\n",
    "                } else {\n",
    "                    signaling <- pathways[pathway_indices]\n",
    "                    break\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Ask if user wants to show only enriched signaling genes\n",
    "        enriched_only <- readline(prompt=\"Show only enriched signaling genes? (y/n): \")\n",
    "        enriched_only <- tolower(enriched_only) == \"y\"\n",
    "\n",
    "        # Visualization options\n",
    "        cat(\"Visualization options:\\n\")\n",
    "        cat(\"1) Violin plot - Shows distribution of gene expression.\\n\")\n",
    "        cat(\"2) Dot plot - Highlights expression levels across cell groups using viridis color palette.\\n\")\n",
    "\n",
    "        # Prompt user for plot type selection (allows multiple selections)\n",
    "        plot_type <- get_numeric_input(\"Enter the number of the plot type(s) you want to use (comma-separated): \", c(1, 2), TRUE)\n",
    "        plot_type_map <- c(\"violin\", \"dot\")\n",
    "        plot_type_selected <- plot_type_map[plot_type]\n",
    "\n",
    "        # Loop over selected plot types and generate plots\n",
    "        for (type in plot_type_selected) {\n",
    "            output_file <- paste0(\"gene_expression_\", type, \".pdf\")\n",
    "            pdf(output_file)\n",
    "            \n",
    "            # Apply viridis color palette for dot plots\n",
    "            if (type == \"dot\") {\n",
    "                library(viridis)  # Load viridis for color palette\n",
    "                plotGeneExpression(cellchat, signaling = signaling, \n",
    "                                   enriched.only = enriched_only, \n",
    "                                   type = type, \n",
    "                                   color = viridis::viridis(100))\n",
    "            } else {\n",
    "                plotGeneExpression(cellchat, signaling = signaling, \n",
    "                                   enriched.only = enriched_only, \n",
    "                                   type = type)\n",
    "            }\n",
    "            \n",
    "            dev.off()\n",
    "            cat(\"Saved:\", output_file, \"\\n\")\n",
    "        }\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "e74c82d3-e9f5-4a5e-8c51-7f2668594cfe",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Identify signaling roles (e.g., dominant senders, receivers) of cell groups as well as the major contributing signaling\n",
    "import rpy2.robjects as ro\n",
    "\n",
    "def identify_signaling_roles():\n",
    "    \"\"\"\n",
    "    Function to draw a series of figures about signaling roles (e.g., dominant senders, receivers) \n",
    "    of cell groups as well as major contributing signaling.\n",
    "    \"\"\"\n",
    "    ro.r('''\n",
    "        pathways <- cellchat@netP$pathways\n",
    "\n",
    "        # Display available pathways with numbering\n",
    "        cat(\"Available pathways:\\n\")\n",
    "        for (i in seq_along(pathways)) {\n",
    "            cat(i, \")\", pathways[i], \"\\n\")\n",
    "        }\n",
    "        cat(\"Total number of pathways:\", length(pathways), \"\\n\")\n",
    "\n",
    "        # Function to get valid numeric input with repeated prompting\n",
    "        get_numeric_input <- function(prompt_msg, valid_range) {\n",
    "            repeat {\n",
    "                input <- readline(prompt=prompt_msg)\n",
    "                num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric vector\n",
    "                \n",
    "                if (any(is.na(num_values)) || any(num_values < valid_range[1]) || any(num_values > valid_range[2])) {\n",
    "                    cat(\"❌ Invalid input. Please enter valid number(s) between\", valid_range[1], \"and\", valid_range[2], \".\\n\")\n",
    "                } else {\n",
    "                    return(num_values)  # Return valid numeric input\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "\n",
    "        # Prompt user for signaling pathways (no \"all\" option)\n",
    "        pathway_indices <- get_numeric_input(\"Enter indices of signaling pathway(s) to analyze (comma-separated): \", c(1, length(pathways)))\n",
    "        signaling <- pathways[pathway_indices]\n",
    "\n",
    "        cat(\"Selected pathways:\\n\")\n",
    "        print(signaling)\n",
    "\n",
    "        # Compute and visualize the network centrality scores\n",
    "        cat(\"Computing network centrality scores...\\n\")\n",
    "        cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = \"netP\")\n",
    "        pdf(\"network_centrality_scores.pdf\", width = 8, height = 2.5)\n",
    "        netAnalysis_signalingRole_network(cellchat, signaling = signaling, width = 8, height = 2.5, font.size = 10)\n",
    "        dev.off()\n",
    "        cat(\"Saved: network_centrality_scores.pdf\\n\")\n",
    "\n",
    "        # Visualize dominant senders and receivers in a 2D space\n",
    "        cat(\"Generating scatter plot for dominant senders and receivers...\\n\")\n",
    "        pdf(\"signaling_role_scatter.pdf\")\n",
    "        gg1 <- netAnalysis_signalingRole_scatter(cellchat, signaling = signaling)\n",
    "        print(gg1)\n",
    "        dev.off()\n",
    "        cat(\"Saved: signaling_role_scatter.pdf\\n\")\n",
    "\n",
    "        # Identify signals contributing the most to outgoing or incoming signaling of certain cell groups\n",
    "        cat(\"Generating heatmaps for signaling roles...\\n\")\n",
    "        pdf(\"signaling_role_heatmap.pdf\")\n",
    "        ht1 <- netAnalysis_signalingRole_heatmap(cellchat, signaling = signaling, pattern = \"outgoing\")\n",
    "        ht2 <- netAnalysis_signalingRole_heatmap(cellchat, signaling = signaling, pattern = \"incoming\")\n",
    "        print(ht1 + ht2)\n",
    "        dev.off()\n",
    "        cat(\"Saved: signaling_role_heatmap.pdf\\n\")\n",
    "\n",
    "        cat(\"Signaling role analysis completed.\\n\")\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "94411331-fbd8-4c50-bc30-b9634fe81a3b",
   "metadata": {},
   "source": [
    "#Identify global communication patterns to explore how multiple cell types and signaling pathways coordinate together\n",
    "#let the user choose pattern = \"outgoing\" or \"incoming\" or all\n",
    "#let the user choose visualization plot among heatmap, river plot, dot plot or all\n",
    "# Load necessary library\n",
    "library(CellChat)\n",
    "\n",
    "# Load CellChat object\n",
    "cellchat <- readRDS(\"cellchat_object.rds\")\n",
    "library(dplyr)\n",
    "gg_obj <- selectK(cellchat, pattern = \"outgoing\")\n",
    "#visualization\n",
    "pdf(\"\")\n",
    "gg_obj\n",
    "dev.off()\n",
    "# Extract data from ggplot object\n",
    "df <- gg_obj$data\n",
    "df$k <- as.numeric(df$k)\n",
    "\n",
    "\n",
    "# Scale the scores within each Measure\n",
    "df <- df %>%\n",
    "  group_by(Measure) %>%\n",
    "  mutate(scaled_score = scale(score)) %>%  # Normalize the scores\n",
    "  arrange(k)\n",
    "\n",
    "# Compute the drop values: scaled_value(n) - scaled_value(n+1)\n",
    "df <- df %>%\n",
    "  mutate(drop = scaled_score - lead(scaled_score)) %>%  # Compute drop values\n",
    "  filter(!is.na(drop))  # Remove NA values from last row\n",
    "\n",
    "# Define the threshold for a significant drop (adjust if needed)\n",
    "threshold <- 0.5  \n",
    "\n",
    "# Keep only significant drops\n",
    "df_significant <- df %>% filter(drop > threshold)\n",
    "\n",
    "# Identify first significant drop for each Measure\n",
    "first_cophenetic_k <- min(df_significant$k[df_significant$Measure == \"Cophenetic\"], na.rm = TRUE)\n",
    "first_silhouette_k <- min(df_significant$k[df_significant$Measure == \"Silhouette\"], na.rm = TRUE)\n",
    "\n",
    "# Ensure we take the later k to make sure both have entered the drop phase\n",
    "first_common_k <- max(first_cophenetic_k, first_silhouette_k, na.rm = TRUE)\n",
    "\n",
    "# Print result to user \n",
    "print(paste(\"First k where both Cophenetic and Silhouette values drop significantly:\", first_common_k))\n",
    "nPatterns = first_common_k\n",
    "cellchat <- identifyCommunicationPatterns(cellchat, pattern = \"outgoing\", k = nPatterns)\n",
    "# river plot\n",
    "netAnalysis_river(cellchat, pattern = \"outgoing\")\n",
    "#> Please make sure you have load `library(ggalluvial)` when running this function\n",
    "# dot plot\n",
    "netAnalysis_dot(cellchat, pattern = \"outgoing\")\n",
    "pdf\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "ed0f1fdb-c6b8-43f9-9933-a54b327fcb13",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Identify global communication patterns to explore how multiple cell types and signaling pathways coordinate together\n",
    "#let the user choose pattern = \"outgoing\" or \"incoming\" or all\n",
    "#let the user choose visualization plot among heatmap, river plot, dot plot or all\n",
    "import rpy2.robjects as ro\n",
    "\n",
    "def identify_global_communication_patterns():\n",
    "    \"\"\"\n",
    "    Identifies global communication patterns and visualizes them using \n",
    "    heatmap, river plot, or dot plot. Ensures valid user input using repeat {} in R.\n",
    "    \"\"\"\n",
    "    \n",
    "    ro.r('''\n",
    "    library(NMF)\n",
    "    library(dplyr)\n",
    "    library(ggalluvial)\n",
    "\n",
    "    # Function to get valid input with repeat loop (number-based choices)\n",
    "    get_valid_choice <- function(prompt_msg, choices, allow_multiple = FALSE) {\n",
    "        repeat {\n",
    "            cat(prompt_msg, \"\\\\n\")\n",
    "            for (i in seq_along(choices)) {\n",
    "                cat(i, \")\", choices[i], \"\\\\n\")\n",
    "            }\n",
    "            input <- readline(\"Enter the number(s) corresponding to your choice (comma-separated for multiple): \")\n",
    "            num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric\n",
    "            \n",
    "            if (any(is.na(num_values)) || any(num_values < 1) || any(num_values > length(choices))) {\n",
    "                cat(\"❌ Invalid input. Please enter valid number(s) from the list.\\\\n\")\n",
    "            } else {\n",
    "                return(choices[num_values])  # Return selected options\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Step 1: Ask user for communication pattern\n",
    "    pattern_options <- c(\"outgoing\", \"incoming\")\n",
    "    pattern_choice <- get_valid_choice(\"Choose communication pattern:\", pattern_options, allow_multiple = FALSE)\n",
    "\n",
    "    # Step 2: Ask user for visualization choices (no \"all\" option)\n",
    "    visualization_options <- c(\"heatmap\", \"river plot\", \"dot plot\")\n",
    "    visualization_choices <- get_valid_choice(\"Choose visualization plot(s):\", visualization_options, allow_multiple = TRUE)\n",
    "\n",
    "    # Function to process communication patterns\n",
    "    process_pattern <- function(pattern) {\n",
    "        repeat {\n",
    "            # Step A: selectK to determine the optimal number of patterns\n",
    "            gg_obj <- selectK(cellchat, pattern = pattern)\n",
    "            pdf(paste0(\"pattern_selection_\", pattern, \".pdf\"))\n",
    "            print(gg_obj)\n",
    "            dev.off()\n",
    "            \n",
    "            # Extract data from ggplot object\n",
    "            df <- gg_obj$data\n",
    "            df$k <- as.numeric(df$k)\n",
    "\n",
    "            # Scale the scores within each Measure\n",
    "            df <- df %>%\n",
    "              group_by(Measure) %>%\n",
    "              mutate(scaled_score = scale(score)) %>%\n",
    "              arrange(k)\n",
    "\n",
    "            # Compute the drop values\n",
    "            df <- df %>%\n",
    "              mutate(drop = scaled_score - lead(scaled_score)) %>%\n",
    "              filter(!is.na(drop))\n",
    "\n",
    "            threshold <- 0.5  \n",
    "            df_significant <- df %>% filter(drop > threshold)\n",
    "\n",
    "            # Identify first significant drop for each Measure\n",
    "            first_cophenetic_k <- min(df_significant$k[df_significant$Measure == \"Cophenetic\"], na.rm = TRUE)\n",
    "            first_silhouette_k <- min(df_significant$k[df_significant$Measure == \"Silhouette\"], na.rm = TRUE)\n",
    "            first_common_k <- max(first_cophenetic_k, first_silhouette_k, na.rm = TRUE)\n",
    "\n",
    "            if (!is.na(first_common_k) && first_common_k > 1) {\n",
    "                break  # Exit loop if we have a valid k\n",
    "            } else {\n",
    "                cat(\"⚠️ No significant drop detected. Please try again with different parameters.\\\\n\")\n",
    "            }\n",
    "        }\n",
    "\n",
    "        cat(\"First k where both Cophenetic and Silhouette values drop significantly:\", first_common_k, \"\\\\n\")\n",
    "        nPatterns <- first_common_k\n",
    "\n",
    "        # Step B: Identify communication patterns\n",
    "        cellchat <- identifyCommunicationPatterns(cellchat, pattern = pattern, k = nPatterns)\n",
    "\n",
    "        # Step C: Generate visualizations\n",
    "        if (\"heatmap\" %in% visualization_choices) {\n",
    "            pdf(paste0(\"heatmap_\", pattern, \".pdf\"))\n",
    "            netAnalysis_signalingRole_heatmap(cellchat, pattern = pattern)\n",
    "            dev.off()\n",
    "            cat(\"Saved: heatmap_\", pattern, \".pdf\\\\n\")\n",
    "        }\n",
    "        \n",
    "        if (\"river plot\" %in% visualization_choices) {\n",
    "            pdf(paste0(\"riverplot_\", pattern, \".pdf\"))\n",
    "            netAnalysis_river(cellchat, pattern = pattern)\n",
    "            dev.off()\n",
    "            cat(\"Saved: riverplot_\", pattern, \".pdf\\\\n\")\n",
    "        }\n",
    "        \n",
    "        if (\"dot plot\" %in% visualization_choices) {\n",
    "            pdf(paste0(\"dotplot_\", pattern, \".pdf\"))\n",
    "            netAnalysis_dot(cellchat, pattern = pattern)\n",
    "            dev.off()\n",
    "            cat(\"Saved: dotplot_\", pattern, \".pdf\\\\n\")\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Process the selected communication pattern\n",
    "    process_pattern(pattern_choice)\n",
    "\n",
    "    cat(\"🎉 Communication pattern identification and visualization completed successfully!\\\\n\")\n",
    "\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "918698c3-a150-49f9-8bfc-48dc92e711f1",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Manifold and classification learning analysis of signaling networks\n",
    "\n",
    "def analyze_signaling_similarity():\n",
    "    \"\"\"\n",
    "    Performs manifold and classification learning analysis on signaling networks \n",
    "    using functional or structural similarity and generates 2D visualization.\n",
    "    \"\"\"\n",
    "\n",
    "    ro.r('''\n",
    "    library(CellChat)\n",
    "\n",
    "    # Load CellChat object\n",
    "    cellchat <- readRDS(\"cellchat_object.rds\")\n",
    "\n",
    "    # Function to get valid input with repeat loop (number-based choices)\n",
    "    get_valid_choice <- function(prompt_msg, choices, allow_multiple = FALSE) {\n",
    "        repeat {\n",
    "            cat(prompt_msg, \"\\\\n\")\n",
    "            for (i in seq_along(choices)) {\n",
    "                cat(i, \")\", choices[i], \"\\\\n\")\n",
    "            }\n",
    "            input <- readline(\"Enter the number(s) corresponding to your choice (comma-separated for multiple): \")\n",
    "            num_values <- as.numeric(unlist(strsplit(input, \",\")))  # Convert to numeric\n",
    "            \n",
    "            if (any(is.na(num_values)) || any(num_values < 1) || any(num_values > length(choices))) {\n",
    "                cat(\"❌ Invalid input. Please enter valid number(s) from the list.\\\\n\")\n",
    "            } else {\n",
    "                return(choices[num_values])  # Return selected options\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Step 1: Ask user for similarity type (allows multiple choices)\n",
    "    similarity_options <- c(\"functional\", \"structural\")\n",
    "    similarity_choices <- get_valid_choice(\"Choose similarity type(s):\", similarity_options, allow_multiple = TRUE)\n",
    "\n",
    "    # Step 2: Ask user whether they want zoom-in visualization\n",
    "    zoom_options <- c(\"No Zoom\", \"Zoom In\")\n",
    "    zoom_choice <- get_valid_choice(\"Do you want to zoom in on the visualization?\", zoom_options, allow_multiple = FALSE)\n",
    "\n",
    "    # Function to process each selected similarity type\n",
    "    process_similarity <- function(similarity_type) {\n",
    "        cat(\"\\\\n🔄 Processing\", similarity_type, \"similarity...\\\\n\")\n",
    "\n",
    "        # Compute network similarity, embedding, and clustering\n",
    "        cellchat <- computeNetSimilarity(cellchat, type = similarity_type)\n",
    "        cellchat <- netEmbedding(cellchat, type = similarity_type)\n",
    "        cellchat <- netClustering(cellchat, type = similarity_type)\n",
    "\n",
    "        # Generate visualization and save PDF\n",
    "        pdf(paste0(\"signaling_similarity_\", similarity_type, \".pdf\"))\n",
    "        netVisual_embedding(cellchat, type = similarity_type, label.size = 3.5)\n",
    "        dev.off()\n",
    "        cat(\"✅ Saved:\", paste0(\"signaling_similarity_\", similarity_type, \".pdf\"), \"\\\\n\")\n",
    "\n",
    "        # If zoom-in option is selected\n",
    "        if (zoom_choice == \"Zoom In\") {\n",
    "            pdf(paste0(\"signaling_similarity_zoom_\", similarity_type, \".pdf\"))\n",
    "            netVisual_embeddingZoomIn(cellchat, type = similarity_type, nCol = 2)\n",
    "            dev.off()\n",
    "            cat(\"✅ Saved:\", paste0(\"signaling_similarity_zoom_\", similarity_type, \".pdf\"), \"\\\\n\")\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Run the process for each selected similarity type\n",
    "    for (similarity in similarity_choices) {\n",
    "        process_similarity(similarity)\n",
    "    }\n",
    "\n",
    "    cat(\"🎉 Signaling similarity analysis completed successfully!\\\\n\")\n",
    "\n",
    "    ''')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "90e6c425-ab1f-4fc7-8e97-f2a3330d1bc8",
   "metadata": {},
   "outputs": [],
   "source": [
    "#save object\n",
    "def save_cellchat(output_file):\n",
    "    \"\"\"Saves the CellChat object to an RDS file.\"\"\"\n",
    "    ro.r(f\"\"\"\n",
    "        saveRDS(cellchat, file = \"{output_file}\")\n",
    "        print(\"CellChat object saved successfully.\")\n",
    "    \"\"\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "75fc93d5-7495-459c-8851-bdcd0c205e89",
   "metadata": {},
   "outputs": [],
   "source": [
    "tools = [\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"format_checker\",\n",
    "            \"description\": \"Check the format of input data files for CellChat analysis.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"input_file\": {\"type\": \"string\", \"description\": \"Path to the gene expression matrix CSV file.\"},\n",
    "                    \"meta_file\": {\"type\": \"string\", \"description\": \"Path to the metadata CSV file.\"}\n",
    "                },\n",
    "                \"required\": [\"input_file\", \"meta_file\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"database_identifier\",\n",
    "            \"description\": \"Identify the appropriate species (human/mouse) and select the CellChat database subsets.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"species\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"human\", \"mouse\"],\n",
    "                        \"description\": \"Specify the species for the CellChat analysis.\"\n",
    "                    },\n",
    "                    \"subsets\": {\n",
    "                        \"type\": \"array\",\n",
    "                        \"items\": {\n",
    "                            \"type\": \"string\",\n",
    "                            \"enum\": [\"Cell-Cell Contact\", \"ECM-Receptor\", \"Non-protein Signaling\", \"Secreted Signaling\"]\n",
    "                        },\n",
    "                        \"description\": \"List of database subsets to include in the analysis.\"\n",
    "                    },\n",
    "                    \"exclude\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"Cell-Cell Contact\", \"ECM-Receptor\", \"Non-protein Signaling\", \"Secreted Signaling\"],\n",
    "                        \"description\": \"Database subset to exclude from analysis (optional).\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"species\", \"subsets\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"cellchat_analysis\",\n",
    "            \"description\": \"Perform the full CellChat analysis pipeline, including data preprocessing, communication inference, and network aggregation.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"input_file\": {\"type\": \"string\", \"description\": \"Path to the gene expression matrix CSV file.\"},\n",
    "                    \"meta_file\": {\"type\": \"string\", \"description\": \"Path to the metadata CSV file.\"}\n",
    "                },\n",
    "                \"required\": [\"input_file\", \"meta_file\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"visual_signal_pathway\",\n",
    "            \"description\": \"Visualize cell signaling pathways using hierarchy, circle, chord, or heatmap plots.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"plot_type\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"hierarchy\", \"circle\", \"chord\", \"heatmap\"],\n",
    "                        \"description\": \"Type of visualization for signaling pathways.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"plot_type\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"visual_LR\",\n",
    "            \"description\": \"Visualize ligand-receptor interactions across sender and receiver cell types.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"sources_use\": {\n",
    "                        \"type\": \"array\",\n",
    "                        \"items\": {\"type\": \"integer\"},\n",
    "                        \"description\": \"Indices of sender cell types.\"\n",
    "                    },\n",
    "                    \"targets_use\": {\n",
    "                        \"type\": \"array\",\n",
    "                        \"items\": {\"type\": \"integer\"},\n",
    "                        \"description\": \"Indices of receiver cell types.\"\n",
    "                    },\n",
    "                    \"signaling\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"description\": \"Signaling pathway(s) to visualize (comma-separated or 'all').\"\n",
    "                    },\n",
    "                    \"plot_type\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"bubble\", \"chord\"],\n",
    "                        \"description\": \"Type of plot to visualize interactions.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"sources_use\", \"targets_use\", \"signaling\", \"plot_type\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"visual_gene\",\n",
    "            \"description\": \"Plot signaling gene expression distribution using violin or dot plots.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"signaling\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"description\": \"Signaling pathway(s) to visualize gene expression (comma-separated or 'all').\"\n",
    "                    },\n",
    "                    \"plot_type\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"violin\", \"dot\"],\n",
    "                        \"description\": \"Type of gene expression plot.\"\n",
    "                    },\n",
    "                    \"enriched_only\": {\n",
    "                        \"type\": \"boolean\",\n",
    "                        \"description\": \"Whether to show only enriched signaling genes.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"signaling\", \"plot_type\", \"enriched_only\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"identify_signaling_roles\",\n",
    "            \"description\": \"Analyze and visualize dominant signaling roles (senders/receivers) of cell groups.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"signaling\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"description\": \"Signaling pathway(s) to analyze roles for (comma-separated or 'all').\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"signaling\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"identify_global_communication_patterns\",\n",
    "            \"description\": \"Analyze global communication patterns and visualize outgoing/incoming signaling using heatmap, river plot, or dot plot.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"pattern\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"enum\": [\"outgoing\", \"incoming\", \"all\"],\n",
    "                        \"description\": \"Pattern of communication to analyze.\"\n",
    "                    },\n",
    "                    \"visualization\": {\n",
    "                        \"type\": \"array\",\n",
    "                        \"items\": {\n",
    "                            \"type\": \"string\",\n",
    "                            \"enum\": [\"heatmap\", \"river plot\", \"dot plot\", \"all\"]\n",
    "                        },\n",
    "                        \"description\": \"List of visualization types to generate.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"pattern\", \"visualization\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"analyze_signaling_similarity\",\n",
    "            \"description\": \"Perform manifold and classification learning analysis on signaling networks based on functional or structural similarity and generate 2D visualizations.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"similarity_type\": {\n",
    "                        \"type\": \"array\",\n",
    "                        \"items\": {\n",
    "                            \"type\": \"string\",\n",
    "                            \"enum\": [\"functional\", \"structural\"]\n",
    "                        },\n",
    "                        \"description\": \"Type(s) of similarity analysis to perform (functional and/or structural).\"\n",
    "                    },\n",
    "                    \"zoom_in\": {\n",
    "                        \"type\": \"boolean\",\n",
    "                        \"description\": \"Whether to generate zoomed-in 2D visualizations.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"similarity_type\", \"zoom_in\"],\n",
    "            },\n",
    "        },\n",
    "    },\n",
    "    {\n",
    "        \"type\": \"function\",\n",
    "        \"function\": {\n",
    "            \"name\": \"save_cellchat\",\n",
    "            \"description\": \"Save the CellChat object for further analysis.\",\n",
    "            \"parameters\": {\n",
    "                \"type\": \"object\",\n",
    "                \"properties\": {\n",
    "                    \"output_file\": {\n",
    "                        \"type\": \"string\",\n",
    "                        \"description\": \"Path to save the CellChat RDS object.\"\n",
    "                    }\n",
    "                },\n",
    "                \"required\": [\"output_file\"],\n",
    "            },\n",
    "        },\n",
    "    }\n",
    "]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "151d0cae-98c0-4dc0-8291-e05b5d188e8d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "\n",
    "def run_conversation(user_prompt):\n",
    "    \"\"\"\n",
    "    Function to handle user input, query AI for required function calls, and execute necessary tools.\n",
    "    \"\"\"\n",
    "\n",
    "    # Step 1: Ask user about the steps before execution\n",
    "    input_file = \"data_input.csv\"\n",
    "    meta_file = \"meta.csv\"\n",
    "\n",
    "    # Start workflow and get user step selection\n",
    "    steps_to_run = host_workflow(input_file, meta_file)\n",
    "\n",
    "    # Step 2: Define available functions in the correct execution order\n",
    "    ordered_functions = [\n",
    "        (\"format_checker\", format_checker, {\"input_file\": input_file, \"meta_file\": meta_file}),\n",
    "        (\"database_identifier\", database_identifier, {}),\n",
    "        (\"cellchat_analysis\", cellchat_analysis, {\"input_file\": input_file, \"meta_file\": meta_file}),\n",
    "        (\"visual_signal_pathway\", visual_signal_pathway, {}),\n",
    "        (\"visual_LR\", visual_LR, {}),\n",
    "        (\"visual_gene\", visual_gene, {}),\n",
    "        (\"identify_signaling_roles\", identify_signaling_roles, {}),\n",
    "        (\"identify_global_communication_patterns\", identify_global_communication_patterns, {}),\n",
    "        (\"analyze_signaling_similarity\", analyze_signaling_similarity, {}),\n",
    "        (\"save_cellchat\", save_cellchat, {}),\n",
    "    ]\n",
    "\n",
    "     # Step 3: Execute only selected functions in order\n",
    "    for function_name, function_to_call, function_args in ordered_functions:\n",
    "        if steps_to_run.get(function_name, False):  # Check if user opted to run this step\n",
    "            print(f\"🟢 Running {function_name}...\")\n",
    "            function_response = function_to_call(**function_args)\n",
    "            print(f\"✅ {function_name} completed.\\n\")\n",
    "\n",
    "    print(\"\\n🎉 **Workflow Completed!** All selected CellChat analysis steps executed successfully.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "523f8af4-d896-45ad-b2f1-1a78573f0858",
   "metadata": {},
   "source": [
    "import json\n",
    "\n",
    "def run_conversation(user_prompt):\n",
    "    \"\"\"\n",
    "    Function to handle user input, automatically identify required visualization steps, \n",
    "    prompt for confirmation, and execute the corresponding functions with plot options.\n",
    "    \"\"\"\n",
    "\n",
    "    # Step 1: Setup input and metadata files\n",
    "    input_file = \"data_input.csv\"\n",
    "    meta_file = \"meta.csv\"\n",
    "\n",
    "    # Step 2: Define available visualization functions with keywords for intent detection\n",
    "    visualization_steps = {\n",
    "        \"visual_signal_pathway\": {\n",
    "            \"description\": \"Visualize Signaling Pathways\",\n",
    "            \"keywords\": [\"pathway\", \"signaling pathway\", \"signal\"],\n",
    "            \"function\": visual_signal_pathway,\n",
    "            \"args\": {}\n",
    "        },\n",
    "        \"visual_LR\": {\n",
    "            \"description\": \"Visualize Ligand-Receptor Interactions\",\n",
    "            \"keywords\": [\"ligand-receptor\", \"ligand\", \"receptor\", \"LR\"],\n",
    "            \"function\": visual_LR,\n",
    "            \"args\": {}\n",
    "        },\n",
    "        \"visual_gene\": {\n",
    "            \"description\": \"Visualize Gene Contributions\",\n",
    "            \"keywords\": [\"gene\", \"gene contribution\", \"gene visualization\"],\n",
    "            \"function\": visual_gene,\n",
    "            \"args\": {}\n",
    "        },\n",
    "        \"identify_signaling_roles\": {\n",
    "            \"description\": \"Identify Signaling Roles\",\n",
    "            \"keywords\": [\"signaling role\", \"role\", \"cell role\", \"communication role\"],\n",
    "            \"function\": identify_signaling_roles,\n",
    "            \"args\": {}\n",
    "        }\n",
    "    }\n",
    "\n",
    "    # Step 3: Create the conversation flow with messages\n",
    "    messages = [\n",
    "        {\n",
    "            \"role\": \"system\",\n",
    "            \"content\": (\n",
    "                \"You are a function-calling LLM that guides users through the CellChat analysis workflow. \"\n",
    "                \"You automatically identify and execute visualization steps based on the user's prompt, \"\n",
    "                \"and prompt for confirmation before execution.\"\n",
    "            )\n",
    "        },\n",
    "        {\n",
    "            \"role\": \"system\",\n",
    "            \"content\": (\n",
    "                \"Available visualization steps include: \"\n",
    "                \"- visual_signal_pathway: Visualizes signaling pathways. \"\n",
    "                \"- visual_LR: Visualizes Ligand-Receptor interactions. \"\n",
    "                \"- visual_gene: Visualizes gene contributions. \"\n",
    "                \"- identify_signaling_roles: Identifies signaling roles of cells.\"\n",
    "            )\n",
    "        },\n",
    "        {\n",
    "            \"role\": \"user\",\n",
    "            \"content\": user_prompt,\n",
    "        }\n",
    "    ]\n",
    "\n",
    "    # Step 4: Check if the main analysis steps are already completed\n",
    "    if \"finished the steps of format_checker\" in user_prompt and \\\n",
    "       \"database_identifier\" in user_prompt and \\\n",
    "       \"cellchat_analysis\" in user_prompt:\n",
    "        \n",
    "        messages.append({\n",
    "            \"role\": \"assistant\",\n",
    "            \"content\": (\n",
    "                \"✅ Detected that initial steps have been completed.\\n\"\n",
    "                \"🔄 Skipping format_checker, database_identifier, and cellchat_analysis.\"\n",
    "            )\n",
    "        })\n",
    "\n",
    "        print(\"\\n🔍 Detecting Required Visualization Steps...\")\n",
    "\n",
    "        # Step 5: Automatically Identify and Confirm Visualization Steps\n",
    "        selected_vis_steps = []\n",
    "        for step, details in visualization_steps.items():\n",
    "            if any(keyword in user_prompt.lower() for keyword in details[\"keywords\"]):\n",
    "                # Confirm with user before running\n",
    "                confirmation = input(f\"\\nDo you want to run {details['description']}? (yes/no): \").strip().lower()\n",
    "                if confirmation in ['yes', 'y']:\n",
    "                    selected_vis_steps.append(step)\n",
    "                    messages.append({\n",
    "                        \"role\": \"assistant\",\n",
    "                        \"content\": f\"✅ Confirmed to run: {details['description']}\"\n",
    "                    })\n",
    "                else:\n",
    "                    messages.append({\n",
    "                        \"role\": \"assistant\",\n",
    "                        \"content\": f\"❌ Skipped: {details['description']}\"\n",
    "                    })\n",
    "\n",
    "        if not selected_vis_steps:\n",
    "            messages.append({\n",
    "                \"role\": \"assistant\",\n",
    "                \"content\": \"⚠️ No visualization steps selected. Exiting.\"\n",
    "            })\n",
    "            print(\"⚠️ No visualization steps selected. Exiting.\")\n",
    "            return \"\\n🚫 No visualization steps executed.\"\n",
    "\n",
    "        # Step 6: Run Selected Visualization Steps with Detailed Options\n",
    "        for step in selected_vis_steps:\n",
    "            function_to_call = visualization_steps[step][\"function\"]\n",
    "            function_args = visualization_steps[step][\"args\"]\n",
    "\n",
    "            # Check if it's visual_LR and offer detailed options\n",
    "            if step == \"visual_LR\":\n",
    "                print(\"\\nVisualization options for Ligand-Receptor Interactions:\")\n",
    "                print(\"1) Hierarchy plot - Shows autocrine and paracrine signaling between cell groups.\")\n",
    "                print(\"2) Circle plot - Displays network communication among all cell types.\")\n",
    "                print(\"3) Chord diagram - Represents signaling relationships in a flexible format.\")\n",
    "                print(\"4) Heatmap - Shows pathway interactions in heatmap format.\")\n",
    "                plot_choices = input(\"Enter the number of the plot type(s) you want to visualize (comma-separated): \")\n",
    "                plot_choices = [int(x.strip()) for x in plot_choices.split(\",\")]\n",
    "\n",
    "                function_args[\"plot_choices\"] = plot_choices  # Pass selected plots to the function\n",
    "\n",
    "            print(f\"\\n🔵 Running {visualization_steps[step]['description']}...\")\n",
    "            function_response = function_to_call(**function_args)\n",
    "            print(f\"✅ {visualization_steps[step]['description']} completed.\\n\")\n",
    "            messages.append({\n",
    "                \"role\": \"assistant\",\n",
    "                \"content\": f\"✅ {visualization_steps[step]['description']} completed.\"\n",
    "            })\n",
    "\n",
    "        messages.append({\n",
    "            \"role\": \"assistant\",\n",
    "            \"content\": \"\\n🎉 **Workflow Completed!** All selected CellChat visualization steps executed successfully.\"\n",
    "        })\n",
    "\n",
    "    else:\n",
    "        messages.append({\n",
    "            \"role\": \"assistant\",\n",
    "            \"content\": (\n",
    "                \"⚠️ It seems that the initial steps have not been completed.\\n\"\n",
    "                \"❗ Please complete format_checker, database_identifier, and cellchat_analysis first.\"\n",
    "            )\n",
    "        })\n",
    "        print(\"⚠️ It seems that the initial steps have not been completed.\")\n",
    "        print(\"❗ Please complete format_checker, database_identifier, and cellchat_analysis first.\")\n",
    "\n",
    "    # Step 7: Display conversation messages\n",
    "    for message in messages:\n",
    "        print(f\"{message['role'].capitalize()}: {message['content']}\")\n",
    "\n",
    "    return \"\\n🎉 **Workflow Completed!** All selected CellChat visualization steps executed successfully.\"\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2af4e04-da4d-47b4-baf4-1343b7879539",
   "metadata": {},
   "source": [
    "import json\n",
    "\n",
    "def run_conversation(user_prompt):\n",
    "    \"\"\"\n",
    "    Function to handle user input, query Groq AI for required function calls, and execute necessary tools.\n",
    "    \"\"\"\n",
    "    messages = [\n",
    "        {\n",
    "            \"role\": \"system\",\n",
    "            \"content\": \"You are an AI-powered interactive agent performing automated CellChat analysis, handling data preprocessing, communication inference, visualization, and role identification. Explain the workflow at the beginning, then ask the user which steps they would like to execute before proceeding. You will guide the user through each step.\",\n",
    "        },\n",
    "        {\n",
    "            \"role\": \"user\",\n",
    "            \"content\": user_prompt,\n",
    "        }\n",
    "    ]\n",
    "    # Step 1: Send initial request to Groq AI\n",
    "    response = client.chat.completions.create(\n",
    "        model=MODEL,\n",
    "        messages=messages,\n",
    "        tools=tools,\n",
    "        tool_choice=\"auto\",\n",
    "        max_tokens=4096\n",
    "    )\n",
    "    response_message = response.choices[0].message\n",
    "    tool_calls = response_message.tool_calls\n",
    "    # Step 2: If function calls are required, execute them sequentially\n",
    "    if tool_calls:\n",
    "        available_functions = {\n",
    "            \"format_checker\": format_checker,\n",
    "            \"database_identifier\": database_identifier,\n",
    "            \"cellchat_analysis\": cellchat_analysis,\n",
    "            \"visual_signal_pathway\": visual_signal_pathway,\n",
    "            \"visual_LR\": visual_LR,\n",
    "            \"visual_gene\": visual_gene,\n",
    "            \"identify_signaling_roles\": identify_signaling_roles,\n",
    "        }\n",
    "        # Append AI response\n",
    "        messages.append(response_message)\n",
    "        # Step 3: Execute function calls\n",
    "        for tool_call in tool_calls:\n",
    "            function_name = tool_call.function.name  # Correct attribute for tool name\n",
    "            function_to_call = available_functions.get(function_name)\n",
    "            function_args = json.loads(tool_call.function.arguments)\n",
    "            if function_to_call:\n",
    "                # Execute the function\n",
    "                function_response = function_to_call(**function_args)\n",
    "                # Append tool execution results\n",
    "                messages.append({\n",
    "                    \"role\": \"tool\",\n",
    "                    \"tool_call_id\": tool_call.id,  # REQUIRED FIELD\n",
    "                    \"name\": function_name,\n",
    "                    \"content\": function_response if isinstance(function_response, str) else json.dumps(function_response),\n",
    "                })\n",
    "        # Step 4: Make a second request to process results\n",
    "        second_response = client.chat.completions.create(\n",
    "            model=MODEL,\n",
    "            messages=messages\n",
    "        )\n",
    "        final_response = second_response.choices[0].message.content\n",
    "    else:\n",
    "        # If no tool calls, return initial response\n",
    "        final_response = response_message.content\n",
    "    return final_response\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "adebe6b1-4cba-44c3-9fba-4aee70efabb1",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "📢 **Welcome to the CellChat Analysis Pipeline!**\n",
      "This workflow consists of multiple steps, each performing a critical function.\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "\n",
      "Select species: Human (h) or Mouse (m):  h\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Available Database Subsets:\n",
      "  1: Secreted Signaling\n",
      "  2: ECM-Receptor\n",
      "  3: Cell-Cell Contact\n",
      "  4: Non-protein Signaling\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "\n",
      "Enter the numbers of the subsets to use (comma-separated, e.g., 1,3):  1\n",
      "\n",
      "Do you want to run CellChat Analysis? (y/n):  y\n",
      "\n",
      "Do you want to run Visualization of Signaling Pathways? (y/n):  y\n",
      "\n",
      "Do you want to run Visualization of Ligand-Receptor? (y/n):  y\n",
      "\n",
      "Do you want to plot the Signaling Gene Expression Distribution? (y/n):  y\n",
      "\n",
      "Do you want to analyze Signaling Roles of Cell Groups? (y/n):  y\n",
      "\n",
      "Do you want to identify global communication patterns? (y/n):  y\n",
      "\n",
      "Do you want to analyze signaling similarity? (y/n):  y\n",
      "\n",
      "Do you want to save the CellChat Object? (y/n):  y\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "✅ **Starting Analysis with Selected Steps...**\n",
      "\n",
      "🔎 **Running Format Checker...**\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Loading required package: dplyr\n",
      "\n",
      "R[write to console]: \n",
      "Attaching package: ‘dplyr’\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:stats’:\n",
      "\n",
      "    filter, lag\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:base’:\n",
      "\n",
      "    intersect, setdiff, setequal, union\n",
      "\n",
      "\n",
      "R[write to console]: Loading required package: igraph\n",
      "\n",
      "R[write to console]: \n",
      "Attaching package: ‘igraph’\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:dplyr’:\n",
      "\n",
      "    as_data_frame, groups, union\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:stats’:\n",
      "\n",
      "    decompose, spectrum\n",
      "\n",
      "\n",
      "R[write to console]: The following object is masked from ‘package:base’:\n",
      "\n",
      "    union\n",
      "\n",
      "\n",
      "R[write to console]: Loading required package: ggplot2\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "    WARNING: The R package \"reticulate\" only fixed recently\n",
      "    an issue that caused a segfault when used with rpy2:\n",
      "    https://github.com/rstudio/reticulate/pull/1188\n",
      "    Make sure that you use a version of that package that includes\n",
      "    the fix.\n",
      "[1] \"Format check passed: Files are correctly formatted for CellChat analysis.\"\n",
      "✅ Format check completed.\n",
      "\n",
      "📚 **Running Database Selection...**\n",
      "Selected species: Human\n",
      "Selected subsets: Secreted Signaling\n",
      " \"Database_identifier completed.\"\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: \n",
      "Attaching package: ‘future’\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:igraph’:\n",
      "\n",
      "    %->%, %<-%\n",
      "\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ Database setup completed: Species = human, Subsets = Secreted Signaling\n",
      "\n",
      "🔬 **Running CellChat Analysis...**\n",
      "[1] \"Data and metadata prepared.\"\n",
      "[1] \"Create a CellChat object from a data matrix\"\n",
      "Set cell identities for the new CellChat object \n",
      "The cell groups used for CellChat analysis are  APOE+ FIB, CD40LG+ TC, cDC1, cDC2, COL11A1+ FIB, FBN1+ FIB, Inflam. DC, Inflam. FIB, Inflam. TC, LC, NKT, TC \n",
      "[1] \"CellChat object created.\"\n",
      "The number of highly variable ligand-receptor pairs used for signaling inference is 1646 \n",
      "[1] \"Preprocessing completed.\"\n",
      "triMean is used for calculating the average gene expression per cell group. \n",
      "[1] \">>> Run CellChat on sc/snRNA-seq data <<< [2025-03-06 15:09:39.371914]\"\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "  |                                                                            \n",
      "  |                                                                      |   0%\n",
      "  |                                                                            \n",
      "  |                                                                      |   1%\n",
      "  |                                                                            \n",
      "  |=                                                                     |   1%\n",
      "  |                                                                            \n",
      "  |=                                                                     |   2%\n",
      "  |                                                                            \n",
      "  |==                                                                    |   2%\n",
      "  |                                                                            \n",
      "  |==                                                                    |   3%\n",
      "  |                                                                            \n",
      "  |==                                                                    |   4%\n",
      "  |                                                                            \n",
      "  |===                                                                   |   4%\n",
      "  |                                                                            \n",
      "  |===                                                                   |   5%\n",
      "  |                                                                            \n",
      "  |====                                                                  |   5%\n",
      "  |                                                                            \n",
      "  |====                                                                  |   6%\n",
      "  |                                                                            \n",
      "  |=====                                                                 |   6%\n",
      "  |                                                                            \n",
      "  |=====                                                                 |   7%\n",
      "  |                                                                            \n",
      "  |=====                                                                 |   8%\n",
      "  |                                                                            \n",
      "  |======                                                                |   8%\n",
      "  |                                                                            \n",
      "  |======                                                                |   9%\n",
      "  |                                                                            \n",
      "  |=======                                                               |   9%\n",
      "  |                                                                            \n",
      "  |=======                                                               |  10%\n",
      "  |                                                                            \n",
      "  |=======                                                               |  11%\n",
      "  |                                                                            \n",
      "  |========                                                              |  11%\n",
      "  |                                                                            \n",
      "  |========                                                              |  12%\n",
      "  |                                                                            \n",
      "  |=========                                                             |  12%\n",
      "  |                                                                            \n",
      "  |=========                                                             |  13%\n",
      "  |                                                                            \n",
      "  |=========                                                             |  14%\n",
      "  |                                                                            \n",
      "  |==========                                                            |  14%\n",
      "  |                                                                            \n",
      "  |==========                                                            |  15%\n",
      "  |                                                                            \n",
      "  |===========                                                           |  15%\n",
      "  |                                                                            \n",
      "  |===========                                                           |  16%\n",
      "  |                                                                            \n",
      "  |============                                                          |  16%\n",
      "  |                                                                            \n",
      "  |============                                                          |  17%\n",
      "  |                                                                            \n",
      "  |============                                                          |  18%\n",
      "  |                                                                            \n",
      "  |=============                                                         |  18%\n",
      "  |                                                                            \n",
      "  |=============                                                         |  19%\n",
      "  |                                                                            \n",
      "  |==============                                                        |  19%\n",
      "  |                                                                            \n",
      "  |==============                                                        |  20%\n",
      "  |                                                                            \n",
      "  |==============                                                        |  21%\n",
      "  |                                                                            \n",
      "  |===============                                                       |  21%\n",
      "  |                                                                            \n",
      "  |===============                                                       |  22%\n",
      "  |                                                                            \n",
      "  |================                                                      |  22%\n",
      "  |                                                                            \n",
      "  |================                                                      |  23%\n",
      "  |                                                                            \n",
      "  |================                                                      |  24%\n",
      "  |                                                                            \n",
      "  |=================                                                     |  24%\n",
      "  |                                                                            \n",
      "  |=================                                                     |  25%\n",
      "  |                                                                            \n",
      "  |==================                                                    |  25%\n",
      "  |                                                                            \n",
      "  |==================                                                    |  26%\n",
      "  |                                                                            \n",
      "  |===================                                                   |  26%\n",
      "  |                                                                            \n",
      "  |===================                                                   |  27%\n",
      "  |                                                                            \n",
      "  |===================                                                   |  28%\n",
      "  |                                                                            \n",
      "  |====================                                                  |  28%\n",
      "  |                                                                            \n",
      "  |====================                                                  |  29%\n",
      "  |                                                                            \n",
      "  |=====================                                                 |  29%\n",
      "  |                                                                            \n",
      "  |=====================                                                 |  30%\n",
      "  |                                                                            \n",
      "  |=====================                                                 |  31%\n",
      "  |                                                                            \n",
      "  |======================                                                |  31%\n",
      "  |                                                                            \n",
      "  |======================                                                |  32%\n",
      "  |                                                                            \n",
      "  |=======================                                               |  32%\n",
      "  |                                                                            \n",
      "  |=======================                                               |  33%\n",
      "  |                                                                            \n",
      "  |=======================                                               |  34%\n",
      "  |                                                                            \n",
      "  |========================                                              |  34%\n",
      "  |                                                                            \n",
      "  |========================                                              |  35%\n",
      "  |                                                                            \n",
      "  |=========================                                             |  35%\n",
      "  |                                                                            \n",
      "  |=========================                                             |  36%\n",
      "  |                                                                            \n",
      "  |==========================                                            |  36%\n",
      "  |                                                                            \n",
      "  |==========================                                            |  37%\n",
      "  |                                                                            \n",
      "  |==========================                                            |  38%\n",
      "  |                                                                            \n",
      "  |===========================                                           |  38%\n",
      "  |                                                                            \n",
      "  |===========================                                           |  39%\n",
      "  |                                                                            \n",
      "  |============================                                          |  39%\n",
      "  |                                                                            \n",
      "  |============================                                          |  40%\n",
      "  |                                                                            \n",
      "  |============================                                          |  41%\n",
      "  |                                                                            \n",
      "  |=============================                                         |  41%\n",
      "  |                                                                            \n",
      "  |=============================                                         |  42%\n",
      "  |                                                                            \n",
      "  |==============================                                        |  42%\n",
      "  |                                                                            \n",
      "  |==============================                                        |  43%\n",
      "  |                                                                            \n",
      "  |==============================                                        |  44%\n",
      "  |                                                                            \n",
      "  |===============================                                       |  44%\n",
      "  |                                                                            \n",
      "  |===============================                                       |  45%\n",
      "  |                                                                            \n",
      "  |================================                                      |  45%\n",
      "  |                                                                            \n",
      "  |================================                                      |  46%\n",
      "  |                                                                            \n",
      "  |=================================                                     |  46%\n",
      "  |                                                                            \n",
      "  |=================================                                     |  47%\n",
      "  |                                                                            \n",
      "  |=================================                                     |  48%\n",
      "  |                                                                            \n",
      "  |==================================                                    |  48%\n",
      "  |                                                                            \n",
      "  |==================================                                    |  49%\n",
      "  |                                                                            \n",
      "  |===================================                                   |  49%\n",
      "  |                                                                            \n",
      "  |===================================                                   |  50%\n",
      "  |                                                                            \n",
      "  |===================================                                   |  51%\n",
      "  |                                                                            \n",
      "  |====================================                                  |  51%\n",
      "  |                                                                            \n",
      "  |====================================                                  |  52%\n",
      "  |                                                                            \n",
      "  |=====================================                                 |  52%\n",
      "  |                                                                            \n",
      "  |=====================================                                 |  53%\n",
      "  |                                                                            \n",
      "  |=====================================                                 |  54%\n",
      "  |                                                                            \n",
      "  |======================================                                |  54%\n",
      "  |                                                                            \n",
      "  |======================================                                |  55%\n",
      "  |                                                                            \n",
      "  |=======================================                               |  55%\n",
      "  |                                                                            \n",
      "  |=======================================                               |  56%\n",
      "  |                                                                            \n",
      "  |========================================                              |  56%\n",
      "  |                                                                            \n",
      "  |========================================                              |  57%\n",
      "  |                                                                            \n",
      "  |========================================                              |  58%\n",
      "  |                                                                            \n",
      "  |=========================================                             |  58%\n",
      "  |                                                                            \n",
      "  |=========================================                             |  59%\n",
      "  |                                                                            \n",
      "  |==========================================                            |  59%\n",
      "  |                                                                            \n",
      "  |==========================================                            |  60%\n",
      "  |                                                                            \n",
      "  |==========================================                            |  61%\n",
      "  |                                                                            \n",
      "  |===========================================                           |  61%\n",
      "  |                                                                            \n",
      "  |===========================================                           |  62%\n",
      "  |                                                                            \n",
      "  |============================================                          |  62%\n",
      "  |                                                                            \n",
      "  |============================================                          |  63%\n",
      "  |                                                                            \n",
      "  |============================================                          |  64%\n",
      "  |                                                                            \n",
      "  |=============================================                         |  64%\n",
      "  |                                                                            \n",
      "  |=============================================                         |  65%\n",
      "  |                                                                            \n",
      "  |==============================================                        |  65%\n",
      "  |                                                                            \n",
      "  |==============================================                        |  66%\n",
      "  |                                                                            \n",
      "  |===============================================                       |  66%\n",
      "  |                                                                            \n",
      "  |===============================================                       |  67%\n",
      "  |                                                                            \n",
      "  |===============================================                       |  68%\n",
      "  |                                                                            \n",
      "  |================================================                      |  68%\n",
      "  |                                                                            \n",
      "  |================================================                      |  69%\n",
      "  |                                                                            \n",
      "  |=================================================                     |  69%\n",
      "  |                                                                            \n",
      "  |=================================================                     |  70%\n",
      "  |                                                                            \n",
      "  |=================================================                     |  71%\n",
      "  |                                                                            \n",
      "  |==================================================                    |  71%\n",
      "  |                                                                            \n",
      "  |==================================================                    |  72%\n",
      "  |                                                                            \n",
      "  |===================================================                   |  72%\n",
      "  |                                                                            \n",
      "  |===================================================                   |  73%\n",
      "  |                                                                            \n",
      "  |===================================================                   |  74%\n",
      "  |                                                                            \n",
      "  |====================================================                  |  74%\n",
      "  |                                                                            \n",
      "  |====================================================                  |  75%\n",
      "  |                                                                            \n",
      "  |=====================================================                 |  75%\n",
      "  |                                                                            \n",
      "  |=====================================================                 |  76%\n",
      "  |                                                                            \n",
      "  |======================================================                |  76%\n",
      "  |                                                                            \n",
      "  |======================================================                |  77%\n",
      "  |                                                                            \n",
      "  |======================================================                |  78%\n",
      "  |                                                                            \n",
      "  |=======================================================               |  78%\n",
      "  |                                                                            \n",
      "  |=======================================================               |  79%\n",
      "  |                                                                            \n",
      "  |========================================================              |  79%\n",
      "  |                                                                            \n",
      "  |========================================================              |  80%\n",
      "  |                                                                            \n",
      "  |========================================================              |  81%\n",
      "  |                                                                            \n",
      "  |=========================================================             |  81%\n",
      "  |                                                                            \n",
      "  |=========================================================             |  82%\n",
      "  |                                                                            \n",
      "  |==========================================================            |  82%\n",
      "  |                                                                            \n",
      "  |==========================================================            |  83%\n",
      "  |                                                                            \n",
      "  |==========================================================            |  84%\n",
      "  |                                                                            \n",
      "  |===========================================================           |  84%\n",
      "  |                                                                            \n",
      "  |===========================================================           |  85%\n",
      "  |                                                                            \n",
      "  |============================================================          |  85%\n",
      "  |                                                                            \n",
      "  |============================================================          |  86%\n",
      "  |                                                                            \n",
      "  |=============================================================         |  86%\n",
      "  |                                                                            \n",
      "  |=============================================================         |  87%\n",
      "  |                                                                            \n",
      "  |=============================================================         |  88%\n",
      "  |                                                                            \n",
      "  |==============================================================        |  88%\n",
      "  |                                                                            \n",
      "  |==============================================================        |  89%\n",
      "  |                                                                            \n",
      "  |===============================================================       |  89%\n",
      "  |                                                                            \n",
      "  |===============================================================       |  90%\n",
      "  |                                                                            \n",
      "  |===============================================================       |  91%\n",
      "  |                                                                            \n",
      "  |================================================================      |  91%\n",
      "  |                                                                            \n",
      "  |================================================================      |  92%\n",
      "  |                                                                            \n",
      "  |=================================================================     |  92%\n",
      "  |                                                                            \n",
      "  |=================================================================     |  93%\n",
      "  |                                                                            \n",
      "  |=================================================================     |  94%\n",
      "  |                                                                            \n",
      "  |==================================================================    |  94%\n",
      "  |                                                                            \n",
      "  |==================================================================    |  95%\n",
      "  |                                                                            \n",
      "  |===================================================================   |  95%\n",
      "  |                                                                            \n",
      "  |===================================================================   |  96%\n",
      "  |                                                                            \n",
      "  |====================================================================  |  96%\n",
      "  |                                                                            \n",
      "  |====================================================================  |  97%\n",
      "  |                                                                            \n",
      "  |====================================================================  |  98%\n",
      "  |                                                                            \n",
      "  |===================================================================== |  98%\n",
      "  |                                                                            \n",
      "  |===================================================================== |  99%\n",
      "  |                                                                            \n",
      "  |======================================================================|  99%\n",
      "  |                                                                            \n",
      "  |======================================================================| 100%\n",
      "R[write to console]: \n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1] \">>> CellChat inference is done. Parameter values are stored in `object@options$parameter` <<< [2025-03-06 15:11:00.961385]\"\n",
      "[1] \"Cell-cell communication inference completed.\"\n",
      "[1] 83.9268\n",
      "[1] \"CellChat analysis completed.\"\n",
      "✅ CellChat analysis completed.\n",
      "\n",
      "📈 **Running Visualization of Signaling Pathways...**\n",
      "Visualization options:\n",
      "1) Hierarchy plot - Shows autocrine and paracrine signaling between cell groups.\n",
      "2) Circle plot - Displays network communication among all cell types.\n",
      "3) Chord diagram - Represents signaling relationships in a flexible format.\n",
      "4) Heatmap - Shows pathway interactions in heatmap format.\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the number of the plot type(s) you want to visualize (comma-separated):  1,2,3,4\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Available cell types:\n",
      "1 ) APOE+ FIB \n",
      "2 ) CD40LG+ TC \n",
      "3 ) cDC1 \n",
      "4 ) cDC2 \n",
      "5 ) COL11A1+ FIB \n",
      "6 ) FBN1+ FIB \n",
      "7 ) Inflam. DC \n",
      "8 ) Inflam. FIB \n",
      "9 ) Inflam. TC \n",
      "10 ) LC \n",
      "11 ) NKT \n",
      "12 ) TC \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of receiver cell types (comma-separated):  1,2,3,4\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Selected receiver cell types:\n",
      "[1] \"APOE+ FIB\"  \"CD40LG+ TC\" \"cDC1\"       \"cDC2\"      \n",
      "Available pathways:\n",
      "1 ) COLLAGEN \n",
      "2 ) MIF \n",
      "3 ) LAMININ \n",
      "4 ) FN1 \n",
      "5 ) MHC-II \n",
      "6 ) ANNEXIN \n",
      "7 ) CypA \n",
      "8 ) GALECTIN \n",
      "9 ) APP \n",
      "10 ) CXCL \n",
      "11 ) CD45 \n",
      "12 ) COMPLEMENT \n",
      "13 ) THBS \n",
      "14 ) Prostaglandin \n",
      "15 ) CLDN \n",
      "16 ) THY1 \n",
      "17 ) CLEC \n",
      "18 ) ICAM \n",
      "19 ) FGF \n",
      "20 ) CD40 \n",
      "21 ) TNF \n",
      "22 ) CCL \n",
      "23 ) GAS \n",
      "24 ) IL4 \n",
      "25 ) IGFBP \n",
      "26 ) JAM \n",
      "27 ) VCAM \n",
      "28 ) CD80 \n",
      "29 ) LIGHT \n",
      "30 ) CADM \n",
      "31 ) CSF \n",
      "32 ) VEGF \n",
      "33 ) GAP \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of signaling pathways to visualize (comma-separated or 'all'):  10\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved: CXCL_hierarchy.pdf \n",
      "Saved: CXCL_circle.pdf \n",
      "Saved: CXCL_chord.pdf \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Do heatmap based on a single object \n",
      "\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved: CXCL_heatmap.pdf \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Do you want to compute and visualize ligand-receptor pair contributions? (y/n):  y\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Enriched Ligand-Receptor Pairs for CXCL :\n",
      "1 ) Interaction: CXCL12_CXCR4 \n",
      "2 ) Interaction: CXCL12_ACKR3 \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Choose a number to visualize a specific L-R pair:  1\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Visualization saved for L-R pair: CXCL12_CXCR4 \n",
      "✅ Visualization completed.\n",
      "\n",
      "📈 **Running Visualization of Ligand-Receptor...**\n",
      "Available cell types:\n",
      "1 ) APOE+ FIB \n",
      "2 ) CD40LG+ TC \n",
      "3 ) cDC1 \n",
      "4 ) cDC2 \n",
      "5 ) COL11A1+ FIB \n",
      "6 ) FBN1+ FIB \n",
      "7 ) Inflam. DC \n",
      "8 ) Inflam. FIB \n",
      "9 ) Inflam. TC \n",
      "10 ) LC \n",
      "11 ) NKT \n",
      "12 ) TC \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of sender cell types (comma-separated):  1,2,3,4\n",
      "Enter indices of receiver cell types (comma-separated):  5,6,7,8,9,10\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Selected sender cell types:\n",
      "[1] \"APOE+ FIB\"  \"CD40LG+ TC\" \"cDC1\"       \"cDC2\"      \n",
      "Selected receiver cell types:\n",
      "[1] \"COL11A1+ FIB\" \"FBN1+ FIB\"    \"Inflam. DC\"   \"Inflam. FIB\"  \"Inflam. TC\"  \n",
      "[6] \"LC\"          \n",
      "Available pathways:\n",
      "1 ) COLLAGEN \n",
      "2 ) MIF \n",
      "3 ) LAMININ \n",
      "4 ) FN1 \n",
      "5 ) MHC-II \n",
      "6 ) ANNEXIN \n",
      "7 ) CypA \n",
      "8 ) GALECTIN \n",
      "9 ) APP \n",
      "10 ) CXCL \n",
      "11 ) CD45 \n",
      "12 ) COMPLEMENT \n",
      "13 ) THBS \n",
      "14 ) Prostaglandin \n",
      "15 ) CLDN \n",
      "16 ) THY1 \n",
      "17 ) CLEC \n",
      "18 ) ICAM \n",
      "19 ) FGF \n",
      "20 ) CD40 \n",
      "21 ) TNF \n",
      "22 ) CCL \n",
      "23 ) GAS \n",
      "24 ) IL4 \n",
      "25 ) IGFBP \n",
      "26 ) JAM \n",
      "27 ) VCAM \n",
      "28 ) CD80 \n",
      "29 ) LIGHT \n",
      "30 ) CADM \n",
      "31 ) CSF \n",
      "32 ) VEGF \n",
      "33 ) GAP \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of signaling pathways to visualize (comma-separated or 'all'):  10,22\n",
      "Do you want to set the order of interacting cell pairs on x-axis? (y/n):  y\n",
      "Sort by target cell types? (y/n):  y\n",
      "Sort by source cell types? (y/n):  y\n",
      "Prioritize source order? (y/n):  y\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Visualization options:\n",
      "1) Bubble plot - Shows significant L-R pairs and interactions.\n",
      "2) Chord diagram - Displays interactions between defined sender and receiver groups.\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the number of the plot type(s) you want to visualize (comma-separated):  1,2\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Comparing communications on a single object \n",
      "\n",
      "\n",
      "R[write to console]: Comparing communications on a single object \n",
      "\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Bubble plot saved as 'bubble_plot_false.pdf' and 'bubble_plot_true.pdf'\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Do you want to show all significant signaling pathways from sources to targets? (y/n):  y\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Chord diagram saved as 'chord_diagram_all.pdf'\n",
      "✅ Visualization completed.\n",
      "\n",
      "📈 **Running Visualization of Gene Expression...**\n",
      "Available pathways:\n",
      "1 ) COLLAGEN \n",
      "2 ) MIF \n",
      "3 ) LAMININ \n",
      "4 ) FN1 \n",
      "5 ) MHC-II \n",
      "6 ) ANNEXIN \n",
      "7 ) CypA \n",
      "8 ) GALECTIN \n",
      "9 ) APP \n",
      "10 ) CXCL \n",
      "11 ) CD45 \n",
      "12 ) COMPLEMENT \n",
      "13 ) THBS \n",
      "14 ) Prostaglandin \n",
      "15 ) CLDN \n",
      "16 ) THY1 \n",
      "17 ) CLEC \n",
      "18 ) ICAM \n",
      "19 ) FGF \n",
      "20 ) CD40 \n",
      "21 ) TNF \n",
      "22 ) CCL \n",
      "23 ) GAS \n",
      "24 ) IL4 \n",
      "25 ) IGFBP \n",
      "26 ) JAM \n",
      "27 ) VCAM \n",
      "28 ) CD80 \n",
      "29 ) LIGHT \n",
      "30 ) CADM \n",
      "31 ) CSF \n",
      "32 ) VEGF \n",
      "33 ) GAP \n",
      "Total number of pathways: 33 \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of signaling pathway(s) to visualize (comma-separated or 'all'):  10,22\n",
      "Show only enriched signaling genes? (y/n):  y\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Visualization options:\n",
      "1) Violin plot - Shows distribution of gene expression.\n",
      "2) Dot plot - Highlights expression levels across cell groups using viridis color palette.\n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the number of the plot type(s) you want to use (comma-separated):  1,2\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Warning:\n",
      "R[write to console]:  Default search for \"data\" layer in \"RNA\" assay yielded no results; utilizing \"counts\" layer instead.\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for y is already present.\n",
      "Adding another scale for y, which will replace the existing scale.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Warning:\n",
      "R[write to console]:  Default search for \"data\" layer in \"RNA\" assay yielded no results; utilizing \"counts\" layer instead.\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for y is already present.\n",
      "Adding another scale for y, which will replace the existing scale.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Warning:\n",
      "R[write to console]:  Default search for \"data\" layer in \"RNA\" assay yielded no results; utilizing \"counts\" layer instead.\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for y is already present.\n",
      "Adding another scale for y, which will replace the existing scale.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Warning:\n",
      "R[write to console]:  Default search for \"data\" layer in \"RNA\" assay yielded no results; utilizing \"counts\" layer instead.\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for y is already present.\n",
      "Adding another scale for y, which will replace the existing scale.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Warning:\n",
      "R[write to console]:  Default search for \"data\" layer in \"RNA\" assay yielded no results; utilizing \"counts\" layer instead.\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for y is already present.\n",
      "Adding another scale for y, which will replace the existing scale.\n",
      "Saved: gene_expression_violin.pdf \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Loading required package: viridisLite\n",
      "\n",
      "R[write to console]: Warning:\n",
      "R[write to console]:  No layers found matching search pattern provided\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scale for colour is already present.\n",
      "Adding another scale for colour, which will replace the existing scale.\n",
      "Saved: gene_expression_dot.pdf \n",
      "✅ Visualization completed.\n",
      "\n",
      "📈 **Running Analysis of Signaling Roles...**\n",
      "Available pathways:\n",
      "1 ) COLLAGEN \n",
      "2 ) MIF \n",
      "3 ) LAMININ \n",
      "4 ) FN1 \n",
      "5 ) MHC-II \n",
      "6 ) ANNEXIN \n",
      "7 ) CypA \n",
      "8 ) GALECTIN \n",
      "9 ) APP \n",
      "10 ) CXCL \n",
      "11 ) CD45 \n",
      "12 ) COMPLEMENT \n",
      "13 ) THBS \n",
      "14 ) Prostaglandin \n",
      "15 ) CLDN \n",
      "16 ) THY1 \n",
      "17 ) CLEC \n",
      "18 ) ICAM \n",
      "19 ) FGF \n",
      "20 ) CD40 \n",
      "21 ) TNF \n",
      "22 ) CCL \n",
      "23 ) GAS \n",
      "24 ) IL4 \n",
      "25 ) IGFBP \n",
      "26 ) JAM \n",
      "27 ) VCAM \n",
      "28 ) CD80 \n",
      "29 ) LIGHT \n",
      "30 ) CADM \n",
      "31 ) CSF \n",
      "32 ) VEGF \n",
      "33 ) GAP \n",
      "Total number of pathways: 33 \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter indices of signaling pathway(s) to analyze (comma-separated):  10,22\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Selected pathways:\n",
      "[1] \"CXCL\" \"CCL\" \n",
      "Computing network centrality scores...\n",
      "Saved: network_centrality_scores.pdf\n",
      "Generating scatter plot for dominant senders and receivers...\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Signaling role analysis on the cell-cell communication network from user's input\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Saved: signaling_role_scatter.pdf\n",
      "Generating heatmaps for signaling roles...\n",
      "Saved: signaling_role_heatmap.pdf\n",
      "Signaling role analysis completed.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Loading required package: registry\n",
      "\n",
      "R[write to console]: Loading required package: rngtools\n",
      "\n",
      "R[write to console]: Loading required package: cluster\n",
      "\n",
      "R[write to console]: NMF - BioConductor layer [OK] | Shared memory capabilities [NO: bigmemory] | Cores 2/2\n",
      "\n",
      "R[write to console]:   To enable shared memory capabilities, try: install.extras('\n",
      "NMF\n",
      "')\n",
      "\n",
      "R[write to console]: \n",
      "Attaching package: ‘NMF’\n",
      "\n",
      "\n",
      "R[write to console]: The following object is masked from ‘package:future’:\n",
      "\n",
      "    run\n",
      "\n",
      "\n",
      "R[write to console]: The following objects are masked from ‘package:igraph’:\n",
      "\n",
      "    algorithm, compare\n",
      "\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "✅ Analysis completed.\n",
      "\n",
      "📈 **Running Analysis of Global Communication Patterns...**\n",
      " hoose communication pattern:\n",
      "1 ) outgoing \n",
      "2 ) incoming \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the number(s) corresponding to your choice (comma-separated for multiple):  1,2\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Choose visualization plot(s): \n",
      "1 ) heatmap \n",
      "2 ) river plot \n",
      "3 ) dot plot \n"
     ]
    },
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the number(s) corresponding to your choice (comma-separated for multiple):  1,2,3\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "First k where both Cophenetic and Silhouette values drop significantly: 3 \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "R[write to console]: Error in match.arg(pattern) : 'arg' must be of length 1\n",
      "\n",
      "R[write to console]: In addition: \n",
      "R[write to console]: Warning message:\n",
      "\n",
      "R[write to console]: In createCellChat(object = data.input, meta = meta, group.by = \"labels\") :\n",
      "R[write to console]: \n",
      " \n",
      "R[write to console]:  The 'meta' data does not have a column named `samples`. We now add this column and all cells are assumed to belong to `sample1`! \n",
      "\n",
      "\n"
     ]
    },
    {
     "ename": "RRuntimeError",
     "evalue": "Error in match.arg(pattern) : 'arg' must be of length 1\n",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRRuntimeError\u001b[0m                             Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[19], line 2\u001b[0m\n\u001b[1;32m      1\u001b[0m user_prompt \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mPerform a full CellChat analysis on my dataset. The input file is \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mdata_input.csv\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m and metadata file is \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmeta.csv\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m.\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m----> 2\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[43mrun_conversation\u001b[49m\u001b[43m(\u001b[49m\u001b[43muser_prompt\u001b[49m\u001b[43m)\u001b[49m)\n",
      "Cell \u001b[0;32mIn[18], line 13\u001b[0m, in \u001b[0;36mrun_conversation\u001b[0;34m(user_prompt)\u001b[0m\n\u001b[1;32m     10\u001b[0m meta_file \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmeta.csv\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m     12\u001b[0m \u001b[38;5;66;03m# Start workflow and get user step selection\u001b[39;00m\n\u001b[0;32m---> 13\u001b[0m steps_to_run \u001b[38;5;241m=\u001b[39m \u001b[43mhost_workflow\u001b[49m\u001b[43m(\u001b[49m\u001b[43minput_file\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmeta_file\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     15\u001b[0m \u001b[38;5;66;03m# Step 2: Define available functions in the correct execution order\u001b[39;00m\n\u001b[1;32m     16\u001b[0m ordered_functions \u001b[38;5;241m=\u001b[39m [\n\u001b[1;32m     17\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mformat_checker\u001b[39m\u001b[38;5;124m\"\u001b[39m, format_checker, {\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124minput_file\u001b[39m\u001b[38;5;124m\"\u001b[39m: input_file, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmeta_file\u001b[39m\u001b[38;5;124m\"\u001b[39m: meta_file}),\n\u001b[1;32m     18\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mdatabase_identifier\u001b[39m\u001b[38;5;124m\"\u001b[39m, database_identifier, {}),\n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m     26\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124msave_cellchat\u001b[39m\u001b[38;5;124m\"\u001b[39m, save_cellchat, {}),\n\u001b[1;32m     27\u001b[0m ]\n",
      "Cell \u001b[0;32mIn[6], line 80\u001b[0m, in \u001b[0;36mhost_workflow\u001b[0;34m(input_file, meta_file)\u001b[0m\n\u001b[1;32m     78\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m steps_to_run[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124midentify_global_communication_patterns\u001b[39m\u001b[38;5;124m\"\u001b[39m]:\n\u001b[1;32m     79\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m📈 **Running Analysis of Global Communication Patterns...**\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m---> 80\u001b[0m     \u001b[43midentify_global_communication_patterns\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     81\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m✅ Analysis completed.\u001b[39m\u001b[38;5;130;01m\\n\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m     83\u001b[0m \u001b[38;5;66;03m# Step 9: Visualization of Signaling Roles\u001b[39;00m\n",
      "Cell \u001b[0;32mIn[14], line 9\u001b[0m, in \u001b[0;36midentify_global_communication_patterns\u001b[0;34m()\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21midentify_global_communication_patterns\u001b[39m():\n\u001b[1;32m      4\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m      5\u001b[0m \u001b[38;5;124;03m    Identifies global communication patterns and visualizes them using \u001b[39;00m\n\u001b[1;32m      6\u001b[0m \u001b[38;5;124;03m    heatmap, river plot, or dot plot. Ensures valid user input using repeat {} in R.\u001b[39;00m\n\u001b[1;32m      7\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[0;32m----> 9\u001b[0m     \u001b[43mro\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mr\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;124;43m'''\u001b[39;49m\n\u001b[1;32m     10\u001b[0m \u001b[38;5;124;43m    library(NMF)\u001b[39;49m\n\u001b[1;32m     11\u001b[0m \u001b[38;5;124;43m    library(dplyr)\u001b[39;49m\n\u001b[1;32m     12\u001b[0m \u001b[38;5;124;43m    library(ggalluvial)\u001b[39;49m\n\u001b[1;32m     13\u001b[0m \n\u001b[1;32m     14\u001b[0m \u001b[38;5;124;43m    # Function to get valid input with repeat loop (number-based choices)\u001b[39;49m\n\u001b[1;32m     15\u001b[0m \u001b[38;5;124;43m    get_valid_choice <- function(prompt_msg, choices, allow_multiple = FALSE) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     16\u001b[0m \u001b[38;5;124;43m        repeat \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     17\u001b[0m \u001b[38;5;124;43m            cat(prompt_msg, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     18\u001b[0m \u001b[38;5;124;43m            for (i in seq_along(choices)) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     19\u001b[0m \u001b[38;5;124;43m                cat(i, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, choices[i], \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     20\u001b[0m \u001b[38;5;124;43m            }\u001b[39;49m\n\u001b[1;32m     21\u001b[0m \u001b[38;5;124;43m            input <- readline(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mEnter the number(s) corresponding to your choice (comma-separated for multiple): \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     22\u001b[0m \u001b[38;5;124;43m            num_values <- as.numeric(unlist(strsplit(input, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m,\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)))  # Convert to numeric\u001b[39;49m\n\u001b[1;32m     23\u001b[0m \u001b[38;5;124;43m            \u001b[39;49m\n\u001b[1;32m     24\u001b[0m \u001b[38;5;124;43m            if (any(is.na(num_values)) || any(num_values < 1) || any(num_values > length(choices))) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     25\u001b[0m \u001b[38;5;124;43m                cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m❌ Invalid input. Please enter valid number(s) from the list.\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     26\u001b[0m \u001b[38;5;124;43m            } else \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     27\u001b[0m \u001b[38;5;124;43m                return(choices[num_values])  # Return selected options\u001b[39;49m\n\u001b[1;32m     28\u001b[0m \u001b[38;5;124;43m            }\u001b[39;49m\n\u001b[1;32m     29\u001b[0m \u001b[38;5;124;43m        }\u001b[39;49m\n\u001b[1;32m     30\u001b[0m \u001b[38;5;124;43m    }\u001b[39;49m\n\u001b[1;32m     31\u001b[0m \n\u001b[1;32m     32\u001b[0m \u001b[38;5;124;43m    # Step 1: Ask user for communication pattern\u001b[39;49m\n\u001b[1;32m     33\u001b[0m \u001b[38;5;124;43m    pattern_options <- c(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43moutgoing\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mincoming\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     34\u001b[0m \u001b[38;5;124;43m    pattern_choice <- get_valid_choice(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mChoose communication pattern:\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern_options, allow_multiple = FALSE)\u001b[39;49m\n\u001b[1;32m     35\u001b[0m \n\u001b[1;32m     36\u001b[0m \u001b[38;5;124;43m    # Step 2: Ask user for visualization choices (no \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mall\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m option)\u001b[39;49m\n\u001b[1;32m     37\u001b[0m \u001b[38;5;124;43m    visualization_options <- c(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mheatmap\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mriver plot\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mdot plot\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     38\u001b[0m \u001b[38;5;124;43m    visualization_choices <- get_valid_choice(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mChoose visualization plot(s):\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, visualization_options, allow_multiple = TRUE)\u001b[39;49m\n\u001b[1;32m     39\u001b[0m \n\u001b[1;32m     40\u001b[0m \u001b[38;5;124;43m    # Function to process communication patterns\u001b[39;49m\n\u001b[1;32m     41\u001b[0m \u001b[38;5;124;43m    process_pattern <- function(pattern) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     42\u001b[0m \u001b[38;5;124;43m        repeat \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     43\u001b[0m \u001b[38;5;124;43m            # Step A: selectK to determine the optimal number of patterns\u001b[39;49m\n\u001b[1;32m     44\u001b[0m \u001b[38;5;124;43m            gg_obj <- selectK(cellchat, pattern = pattern)\u001b[39;49m\n\u001b[1;32m     45\u001b[0m \u001b[38;5;124;43m            pdf(paste0(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mpattern_selection_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m))\u001b[39;49m\n\u001b[1;32m     46\u001b[0m \u001b[38;5;124;43m            print(gg_obj)\u001b[39;49m\n\u001b[1;32m     47\u001b[0m \u001b[38;5;124;43m            dev.off()\u001b[39;49m\n\u001b[1;32m     48\u001b[0m \u001b[38;5;124;43m            \u001b[39;49m\n\u001b[1;32m     49\u001b[0m \u001b[38;5;124;43m            # Extract data from ggplot object\u001b[39;49m\n\u001b[1;32m     50\u001b[0m \u001b[38;5;124;43m            df <- gg_obj$data\u001b[39;49m\n\u001b[1;32m     51\u001b[0m \u001b[38;5;124;43m            df$k <- as.numeric(df$k)\u001b[39;49m\n\u001b[1;32m     52\u001b[0m \n\u001b[1;32m     53\u001b[0m \u001b[38;5;124;43m            # Scale the scores within each Measure\u001b[39;49m\n\u001b[1;32m     54\u001b[0m \u001b[38;5;124;43m            df <- df \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\n\u001b[1;32m     55\u001b[0m \u001b[38;5;124;43m              group_by(Measure) \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\n\u001b[1;32m     56\u001b[0m \u001b[38;5;124;43m              mutate(scaled_score = scale(score)) \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\n\u001b[1;32m     57\u001b[0m \u001b[38;5;124;43m              arrange(k)\u001b[39;49m\n\u001b[1;32m     58\u001b[0m \n\u001b[1;32m     59\u001b[0m \u001b[38;5;124;43m            # Compute the drop values\u001b[39;49m\n\u001b[1;32m     60\u001b[0m \u001b[38;5;124;43m            df <- df \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\n\u001b[1;32m     61\u001b[0m \u001b[38;5;124;43m              mutate(drop = scaled_score - lead(scaled_score)) \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\n\u001b[1;32m     62\u001b[0m \u001b[38;5;124;43m              filter(!is.na(drop))\u001b[39;49m\n\u001b[1;32m     63\u001b[0m \n\u001b[1;32m     64\u001b[0m \u001b[38;5;124;43m            threshold <- 0.5  \u001b[39;49m\n\u001b[1;32m     65\u001b[0m \u001b[38;5;124;43m            df_significant <- df \u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m>\u001b[39;49m\u001b[38;5;132;43;01m% f\u001b[39;49;00m\u001b[38;5;124;43milter(drop > threshold)\u001b[39;49m\n\u001b[1;32m     66\u001b[0m \n\u001b[1;32m     67\u001b[0m \u001b[38;5;124;43m            # Identify first significant drop for each Measure\u001b[39;49m\n\u001b[1;32m     68\u001b[0m \u001b[38;5;124;43m            first_cophenetic_k <- min(df_significant$k[df_significant$Measure == \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mCophenetic\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m], na.rm = TRUE)\u001b[39;49m\n\u001b[1;32m     69\u001b[0m \u001b[38;5;124;43m            first_silhouette_k <- min(df_significant$k[df_significant$Measure == \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mSilhouette\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m], na.rm = TRUE)\u001b[39;49m\n\u001b[1;32m     70\u001b[0m \u001b[38;5;124;43m            first_common_k <- max(first_cophenetic_k, first_silhouette_k, na.rm = TRUE)\u001b[39;49m\n\u001b[1;32m     71\u001b[0m \n\u001b[1;32m     72\u001b[0m \u001b[38;5;124;43m            if (!is.na(first_common_k) && first_common_k > 1) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     73\u001b[0m \u001b[38;5;124;43m                break  # Exit loop if we have a valid k\u001b[39;49m\n\u001b[1;32m     74\u001b[0m \u001b[38;5;124;43m            } else \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     75\u001b[0m \u001b[38;5;124;43m                cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m⚠️ No significant drop detected. Please try again with different parameters.\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     76\u001b[0m \u001b[38;5;124;43m            }\u001b[39;49m\n\u001b[1;32m     77\u001b[0m \u001b[38;5;124;43m        }\u001b[39;49m\n\u001b[1;32m     78\u001b[0m \n\u001b[1;32m     79\u001b[0m \u001b[38;5;124;43m        cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mFirst k where both Cophenetic and Silhouette values drop significantly:\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, first_common_k, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     80\u001b[0m \u001b[38;5;124;43m        nPatterns <- first_common_k\u001b[39;49m\n\u001b[1;32m     81\u001b[0m \n\u001b[1;32m     82\u001b[0m \u001b[38;5;124;43m        # Step B: Identify communication patterns\u001b[39;49m\n\u001b[1;32m     83\u001b[0m \u001b[38;5;124;43m        cellchat <- identifyCommunicationPatterns(cellchat, pattern = pattern, k = nPatterns)\u001b[39;49m\n\u001b[1;32m     84\u001b[0m \n\u001b[1;32m     85\u001b[0m \u001b[38;5;124;43m        # Step C: Generate visualizations\u001b[39;49m\n\u001b[1;32m     86\u001b[0m \u001b[38;5;124;43m        if (\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mheatmap\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m \u001b[39;49m\u001b[38;5;132;43;01m%i\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m visualization_choices) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     87\u001b[0m \u001b[38;5;124;43m            pdf(paste0(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mheatmap_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m))\u001b[39;49m\n\u001b[1;32m     88\u001b[0m \u001b[38;5;124;43m            netAnalysis_signalingRole_heatmap(cellchat, pattern = pattern)\u001b[39;49m\n\u001b[1;32m     89\u001b[0m \u001b[38;5;124;43m            dev.off()\u001b[39;49m\n\u001b[1;32m     90\u001b[0m \u001b[38;5;124;43m            cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mSaved: heatmap_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     91\u001b[0m \u001b[38;5;124;43m        }\u001b[39;49m\n\u001b[1;32m     92\u001b[0m \u001b[38;5;124;43m        \u001b[39;49m\n\u001b[1;32m     93\u001b[0m \u001b[38;5;124;43m        if (\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mriver plot\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m \u001b[39;49m\u001b[38;5;132;43;01m%i\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m visualization_choices) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m     94\u001b[0m \u001b[38;5;124;43m            pdf(paste0(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mriverplot_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m))\u001b[39;49m\n\u001b[1;32m     95\u001b[0m \u001b[38;5;124;43m            netAnalysis_river(cellchat, pattern = pattern)\u001b[39;49m\n\u001b[1;32m     96\u001b[0m \u001b[38;5;124;43m            dev.off()\u001b[39;49m\n\u001b[1;32m     97\u001b[0m \u001b[38;5;124;43m            cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mSaved: riverplot_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m     98\u001b[0m \u001b[38;5;124;43m        }\u001b[39;49m\n\u001b[1;32m     99\u001b[0m \u001b[38;5;124;43m        \u001b[39;49m\n\u001b[1;32m    100\u001b[0m \u001b[38;5;124;43m        if (\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mdot plot\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m \u001b[39;49m\u001b[38;5;132;43;01m%i\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m%\u001b[39;49m\u001b[38;5;124;43m visualization_choices) \u001b[39;49m\u001b[38;5;124;43m{\u001b[39;49m\n\u001b[1;32m    101\u001b[0m \u001b[38;5;124;43m            pdf(paste0(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mdotplot_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m))\u001b[39;49m\n\u001b[1;32m    102\u001b[0m \u001b[38;5;124;43m            netAnalysis_dot(cellchat, pattern = pattern)\u001b[39;49m\n\u001b[1;32m    103\u001b[0m \u001b[38;5;124;43m            dev.off()\u001b[39;49m\n\u001b[1;32m    104\u001b[0m \u001b[38;5;124;43m            cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mSaved: dotplot_\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m, pattern, \u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m.pdf\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m    105\u001b[0m \u001b[38;5;124;43m        }\u001b[39;49m\n\u001b[1;32m    106\u001b[0m \u001b[38;5;124;43m    }\u001b[39;49m\n\u001b[1;32m    107\u001b[0m \n\u001b[1;32m    108\u001b[0m \u001b[38;5;124;43m    # Process the selected communication pattern\u001b[39;49m\n\u001b[1;32m    109\u001b[0m \u001b[38;5;124;43m    process_pattern(pattern_choice)\u001b[39;49m\n\u001b[1;32m    110\u001b[0m \n\u001b[1;32m    111\u001b[0m \u001b[38;5;124;43m    cat(\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m🎉 Communication pattern identification and visualization completed successfully!\u001b[39;49m\u001b[38;5;130;43;01m\\\\\u001b[39;49;00m\u001b[38;5;124;43mn\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43m)\u001b[39;49m\n\u001b[1;32m    112\u001b[0m \n\u001b[1;32m    113\u001b[0m \u001b[38;5;124;43m    \u001b[39;49m\u001b[38;5;124;43m'''\u001b[39;49m\u001b[43m)\u001b[49m\n",
      "File \u001b[0;32m/opt/anaconda3/envs/groq/lib/python3.12/site-packages/rpy2/robjects/__init__.py:459\u001b[0m, in \u001b[0;36mR.__call__\u001b[0;34m(self, string)\u001b[0m\n\u001b[1;32m    457\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21m__call__\u001b[39m(\u001b[38;5;28mself\u001b[39m, string):\n\u001b[1;32m    458\u001b[0m     p \u001b[38;5;241m=\u001b[39m rinterface\u001b[38;5;241m.\u001b[39mparse(string)\n\u001b[0;32m--> 459\u001b[0m     res \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43meval\u001b[49m\u001b[43m(\u001b[49m\u001b[43mp\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    460\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m conversion\u001b[38;5;241m.\u001b[39mget_conversion()\u001b[38;5;241m.\u001b[39mrpy2py(res)\n",
      "File \u001b[0;32m/opt/anaconda3/envs/groq/lib/python3.12/site-packages/rpy2/robjects/functions.py:208\u001b[0m, in \u001b[0;36mSignatureTranslatedFunction.__call__\u001b[0;34m(self, *args, **kwargs)\u001b[0m\n\u001b[1;32m    206\u001b[0m         v \u001b[38;5;241m=\u001b[39m kwargs\u001b[38;5;241m.\u001b[39mpop(k)\n\u001b[1;32m    207\u001b[0m         kwargs[r_k] \u001b[38;5;241m=\u001b[39m v\n\u001b[0;32m--> 208\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m (\u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mSignatureTranslatedFunction\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m    209\u001b[0m \u001b[43m        \u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[38;5;21;43m__call__\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m)\n",
      "File \u001b[0;32m/opt/anaconda3/envs/groq/lib/python3.12/site-packages/rpy2/robjects/functions.py:131\u001b[0m, in \u001b[0;36mFunction.__call__\u001b[0;34m(self, *args, **kwargs)\u001b[0m\n\u001b[1;32m    129\u001b[0m     \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    130\u001b[0m         new_kwargs[k] \u001b[38;5;241m=\u001b[39m cv\u001b[38;5;241m.\u001b[39mpy2rpy(v)\n\u001b[0;32m--> 131\u001b[0m res \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43mFunction\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[38;5;21;43m__call__\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mnew_args\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mnew_kwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    132\u001b[0m res \u001b[38;5;241m=\u001b[39m cv\u001b[38;5;241m.\u001b[39mrpy2py(res)\n\u001b[1;32m    133\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m res\n",
      "File \u001b[0;32m/opt/anaconda3/envs/groq/lib/python3.12/site-packages/rpy2/rinterface_lib/conversion.py:45\u001b[0m, in \u001b[0;36m_cdata_res_to_rinterface.<locals>._\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m     44\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21m_\u001b[39m(\u001b[38;5;241m*\u001b[39margs, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs):\n\u001b[0;32m---> 45\u001b[0m     cdata \u001b[38;5;241m=\u001b[39m \u001b[43mfunction\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     46\u001b[0m     \u001b[38;5;66;03m# TODO: test cdata is of the expected CType\u001b[39;00m\n\u001b[1;32m     47\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m _cdata_to_rinterface(cdata)\n",
      "File \u001b[0;32m/opt/anaconda3/envs/groq/lib/python3.12/site-packages/rpy2/rinterface.py:817\u001b[0m, in \u001b[0;36mSexpClosure.__call__\u001b[0;34m(self, *args, **kwargs)\u001b[0m\n\u001b[1;32m    810\u001b[0m     res \u001b[38;5;241m=\u001b[39m rmemory\u001b[38;5;241m.\u001b[39mprotect(\n\u001b[1;32m    811\u001b[0m         openrlib\u001b[38;5;241m.\u001b[39mrlib\u001b[38;5;241m.\u001b[39mR_tryEval(\n\u001b[1;32m    812\u001b[0m             call_r,\n\u001b[1;32m    813\u001b[0m             call_context\u001b[38;5;241m.\u001b[39m__sexp__\u001b[38;5;241m.\u001b[39m_cdata,\n\u001b[1;32m    814\u001b[0m             error_occured)\n\u001b[1;32m    815\u001b[0m     )\n\u001b[1;32m    816\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m error_occured[\u001b[38;5;241m0\u001b[39m]:\n\u001b[0;32m--> 817\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m embedded\u001b[38;5;241m.\u001b[39mRRuntimeError(_rinterface\u001b[38;5;241m.\u001b[39m_geterrmessage())\n\u001b[1;32m    818\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m res\n",
      "\u001b[0;31mRRuntimeError\u001b[0m: Error in match.arg(pattern) : 'arg' must be of length 1\n"
     ]
    }
   ],
   "source": [
    "user_prompt = \"Perform a full CellChat analysis on my dataset. The input file is 'data_input.csv' and metadata file is 'meta.csv'.\"\n",
    "print(run_conversation(user_prompt))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "04a4f605-9871-4e02-8f6c-c76f7fcd6908",
   "metadata": {
    "scrolled": true
   },
   "source": [
    "user_prompt = \"Now I have cellchat_object.rds which has finished the steps of format_checker, database_identifier and cellchat_analysis, help me run Visualization of Ligand-Receptor.\"\n",
    "print(run_conversation(user_prompt))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2d9006a-293f-4911-9c1d-dfcc6de8f02b",
   "metadata": {},
   "source": [
    "# Example Usage\n",
    "user_prompt = \"Perform a full CellChat analysis on my dataset. The input file is 'data_input.csv' and metadata file is 'meta.csv'.\"\n",
    "print(run_conversation(user_prompt))\n",
    "\n",
    "\n",
    "\n",
    "user_prompt = \"Help me do cell-cell communication analysis using data_input.csv and meta.csv in the current folder \"\n",
    "print(run_conversation(user_prompt))\n",
    "\n",
    "\n",
    "\n",
    "user_prompt = \"Visualize the communication network as a circle plot.\"\n",
    "print(run_conversation(user_prompt))\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fc7ca53e-824b-4701-8cd6-bb7920524d99",
   "metadata": {},
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Data\n",
    "methods = ['CellChat Agent', 'CellAgent']\n",
    "correct_rates = [63.76, 34.82]\n",
    "\n",
    "# Create bar plot\n",
    "plt.figure(figsize=(6, 4))\n",
    "plt.bar(methods, correct_rates)\n",
    "plt.xlabel('Methods')\n",
    "plt.ylabel('Correct Rate (%)')\n",
    "plt.title('Correct Rate Comparison')\n",
    "\n",
    "# Save as PDF\n",
    "pdf_filename = \"correct_rate_comparison.pdf\"\n",
    "plt.savefig(pdf_filename, format='pdf')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python (groq)",
   "language": "python",
   "name": "groq"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
